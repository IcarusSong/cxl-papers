
# Memory Sharing with CXL: Hardware and Software Design Approaches

## 作者以及出版物
### 作者
Sunita Jain, Nagaradhesh Yeleswarapu, Hasan Al Maruf, Rita Gupta，均来自 AMD, Inc.

### 出版物
arXiv:2404.03245v1

## 文章背景
当前的服务器架构上，计算资源与内存资源是紧耦合的，并且内存工艺的发展也远落后于CPU。同时，这种紧耦合限制了服务器的灵活设计，导致计算、网络、I/O以及内存资源的搁置。从而造成数据中心TCO的增加。

CXL作为一种开放互联标准，有望对计算和内存资源进行解耦合。
- CXL 1.0/1.1 支持点对点连接 。
- CXL 2.0 通过交换（switching，单级交换）技术支持内存池化（memory pooling）。
- CXL 3.0 进一步支持多级交换和非树形拓扑（如Spine/Leaf、Mesh），极大地扩展了可组合机架级服务器的设计可能性 。更重要的是，CXL 3.0引入了跨多主机的内存共享（memory sharing）功能，并能通过反向无效化（Back Invalidation, BI）机制来维护硬件缓存一致性 

## 相关工作以及局限性
Linux系统中的共享内存机制: Linux通过System V或POSIX API（如shmget, mmap）提供了成熟的进程间共享内存功能，这对于单机内的多进程通信非常高效。
- 局限性: 这些机制被严格限制在单一主机内部，无法直接应用于如图2所示的多主机（multi-headed）CXL系统中的跨主机内存共享
![](https://pic1.imgdb.cn/item/6874c57558cb8da5c8ac0798.png)



CXL本身的局限性：
- CXL2.0：议本身不提供对内存共享的硬件支持 。因此，要实现共享，必须完全通过软件层面来确保数据的一致性和并发控制，这对软件设计提出了很高的要求
- CXL3.0：入了硬件一致性支持（通过BI），但同样面临挑战 
  - 精确的窥探过滤器（Snoop Filter）: 如果对每一条缓存行（64B）进行精确跟踪，在共享内存容量巨大（如TB级别）时，其硬件开销将变得不切实际
  - 不精确的窥探过滤器：使用更粗的粒度（4KB）进行跟踪，但这可能会造成不必要的BI窥探，从而降低性能。




## 论文发现以及论文贡献
**论文发现**: 核心发现是，无论是纯软件方案还是纯硬件方案，在实现大规模、高效的CXL内存共享时都存在显著的权衡和挑战 。CXL 2.0缺乏硬件支持，而CXL 3.0的硬件支持在面对大容量共享内存时，要么开销过大，要么性能不佳 。因此，有必要探索软件、硬件协同设计的混合模型。

**论文共享**：
- 提出了混合一致性模型: 针对CXL 3.0，文章提出了一种混合模型 。该模型建议仅对一小部分“关键”内存区域（如用于原子操作、信号量、元数据等）使用精确的、硬件管理的窥探过滤器来保证一致性，而对其余大部分共享区域则通过软件来管理一致性 。这种方法旨在性能开销和硬件实现的复杂度之间取得平衡
![](https://pic1.imgdb.cn/item/6874c55058cb8da5c8ac05f4.png)
- 设计了两种软件共享框架: 针对缺乏硬件支持的场景（如CXL 2.0），文章提出了两种可行的软件实现方案 ：
  - 自定义框架: 一个包含CXL驱动、Verbs抽象层和上层协议的完整软件栈，用于实现跨主机通信、同步和内存管理
  ![](https://pic1.imgdb.cn/item/6874c62d58cb8da5c8ac0c66.png)
  - 基于OpenSHMEM的实现: 提议扩展并利用成熟的PGAS（Partitioned Global Address Space）库——OpenSHMEM，来简化跨主机共享内存应用的开发
  ![](https://pic1.imgdb.cn/item/6874c64758cb8da5c8ac0d13.png)
- 设计了硬件辅助共享原型: 文章详细描述了一个基于双头CXL Type-3设备的硬件辅助共享内存原型设计 。该设计通过在CXL.io的MMIO空间中实现硬件原子操作来控制共享内存的写访问，从而简化了并发控制
  - 核心机制: 通过在CXL.io的MMIO（内存映射I/O）区域中实现硬件原子操作（如Test & Set）来充当锁机制 。设计一个访问控制逻辑（Access Control Logic）层来管理锁的授予和释放，支持“单一写入者，多个读取者”的访问模式（读操作无需原子保护）
  - 软硬协同流程: 应用程序通过驱动程序请求写权限 。驱动程序向硬件发送指令以获取锁 。硬件的访问控制逻辑处理请求并设置标志位，然后驱动通知应用程序可以写入 。写入完成后，应用程序通过驱动释放锁，硬件随之复位标志位
![](https://pic1.imgdb.cn/item/6874c6ae58cb8da5c8ac0fc3.png)