<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/IcarusSong/cxl-papers.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">TPP：Transparent Page Placement for CXL-Enabled Tiered-Memory</a><ul><li><a href="#h2-1">作者以及出版物</a><ul><li><a href="#h3-2">作者</a></li></ul><ul><li><a href="#h3-3">出版物</a></li></ul></li></ul><ul><li><a href="#h2-4">内存分层出现背景</a></li></ul><ul><li><a href="#h2-5">内存分层带来的影响</a></li></ul><ul><li><a href="#h2-6">数据中心应用的特征分析</a><ul><li><a href="#h3-7">Chameleon介绍</a></li></ul><ul><li><a href="#h3-8">Chameleon 的工作流程</a><ul><li><a href="#h4-9">Collector 的工作流程</a></li></ul><ul><li><a href="#h4-10">Worker</a></li></ul><ul><li><a href="#h4-11">工作流的双缓冲机制</a></li></ul><ul><li><a href="#h4-12">实际应用中的表现</a></li></ul></li></ul><ul><li><a href="#h3-13">工作负载概述</a></li></ul><ul><li><a href="#h3-14">3.2 页面热度分布</a></li></ul><ul><li><a href="#h3-15">3.3 不同页面类型的热度差异</a></li></ul><ul><li><a href="#h3-16">3.4 不同页面类型随时间的变化</a></li></ul><ul><li><a href="#h3-17">3.5 页面类型对性能的影响</a></li></ul><ul><li><a href="#h3-18">3.6 冷页面的再访问时间</a></li></ul><ul><li><a href="#h3-19">总结</a></li></ul></li></ul><ul><li><a href="#h2-20">TPP的设计原则</a><ul><li><a href="#h3-21">实现层级的选择</a></li></ul><ul><li><a href="#h3-22">页面热度检测</a></li></ul><ul><li><a href="#h3-23">CXL-Memory 的抽象</a></li></ul><ul><li><a href="#h3-24">设计目标</a></li></ul></li></ul><ul><li><a href="#h2-25">TPP的具体设计</a><ul><li><a href="#h3-26">轻量级回收与迁移</a></li></ul><ul><li><a href="#h3-27">分离分配与回收路径</a></li></ul><ul><li><a href="#h3-28">热页面提升机制</a></li></ul><ul><li><a href="#h3-29">页面类型感知的分配策略</a></li></ul></li></ul><ul><li><a href="#h2-30">TPP评估</a><ul><li><a href="#h3-31">实验设置</a></li></ul><ul><li><a href="#h3-32">TPP 的有效性</a></li></ul><ul><li><a href="#h3-33">TPP 组件的影响</a></li></ul><ul><li><a href="#h3-34">与现有解决方案的对比</a></li></ul><ul><li><a href="#h3-35">总结</a></li></ul></li></ul><ul><li><a href="#h2-36">结论</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">TPP：Transparent Page Placement for CXL-Enabled Tiered-Memory</h1><h2 id="h2-1">作者以及出版物</h2><h3 id="h3-2">作者</h3><p>Hasan Al Maruf（美国密歇根大学）、Johannes Weiner（美国Meta公司）、Chris Petersen（美国Meta公司）、Hao Wang（美国英伟达）、Niket Agarwal（美国英伟达）、Mosharaf Chowdhury（美国密歇根大学）、Abbishek Dhanotia（美国Meta公司）、Pallab Bhattacharya（美国英伟达）、Shobhit Kanaujia（美国Meta公司）、Prakash Chauhan（美国Meta公司）</p><h3 id="h3-3">出版物</h3><p>ASPLOS ’23</p><h2 id="h2-4">内存分层出现背景</h2><p>在数据中心中，应用对内存的需求激增，由于增加DRAM带来的高额成本以及拓展内存带来的技术挑战，使得内存成为超大规模数据中心基础设置支出的重要部分，微软表示，50%的服务器总成本来自DRAM。 <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67f7bd2688c538a9b5c8dd76.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67f7bd2688c538a9b5c8dd76.png" alt=""></a> 可以利用程序局部性，进行存储分层，利用高速存储的延迟和低俗内存的容量，降低数据中心的内存成本。</p><p>在CXL之前的内存分层技术（PCIe、RDMA），相较于主存而言，都有更高的延迟，在数据在不同层级的内存层次结构中分配不当时，会造成严重的性能损失。</p><p>CXL的出现解决了这一问题，既解决了非DRAM内存的高延迟问题，又保留了类似 DRAM 的高带宽和细粒度访问能力。 <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67f7bb8188c538a9b5c8da2a.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67f7bb8188c538a9b5c8da2a.png" alt=""></a> <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67f7bb9588c538a9b5c8da69.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67f7bb9588c538a9b5c8da69.png" alt=""></a></p><h2 id="h2-5">内存分层带来的影响</h2><p>为了测试内存分层是否有意，需要了解数据中心中各类应用的内存访问行为。对于每个应用，需要了解其内存中有多少在特定时间段内保持<b>热、温或冷</b>，以及有多少内存是短期的，或者是长期的。</p><p>现有的基于空闲页面跟踪（IPT）的工具无法满足需求，原因包括以下几点：</p><ol start="1"><li><b>内核修改限制</b>：这些工具需要对内核进行修改，这在生产环境中通常是不可行的。</li></ol><ol start="2"><li><b>高资源开销</b>：持续的访问位采样和分析会导致过高的CPU和内存开销，难以扩展到大工作集。</li></ol><ol start="3"><li><b>缺乏页类型敏感性</b>：应用程序对不同类型内存页（如匿名页、文件页缓存、共享内存等）的敏感性不同，而现有工具未能考虑这一点。</li></ol><h2 id="h2-6">数据中心应用的特征分析</h2><p>作者通过开发 <b>Chameleon</b> 工具对数据中心应用的内存使用行为进行了详细分析。Chameleon 是一种轻量级的用户空间工具，能够高效地表征应用程序的内存访问模式，而无需修改内核或干扰生产环境中的运行应用。</p><h3 id="h3-7">Chameleon介绍</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67f7c71a88c538a9b5c8ef94.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67f7c71a88c538a9b5c8ef94.png" alt=""></a></p><h3 id="h3-8">Chameleon 的工作流程</h3><p>Chameleon是一种轻量级的用户空间工具，用于表征数据中心应用程序的内存访问行为。它通过硬件性能事件采样（PEBS）机制来生成应用程序的内存访问热图，并帮助分析不同页面类型的热度分布。以下是其工作流程的详细说明：</p><p>Chameleon 的设计目标是：</p><ul><li>在不影响生产环境运行的情况下快速部署。</li></ul><ul><li>提供低开销的内存访问行为分析。</li></ul><ul><li>支持对虚拟地址空间和物理地址空间的分析。</li></ul><p>为实现这些目标，Chameleon 由两个主要组件组成，分别运行在不同的线程中：</p><ul><li><b>Collector（收集器）</b>：负责从硬件性能计数器中采样内存访问事件。</li></ul><ul><li><b>Worker（处理线程）</b>：负责处理采样数据并生成内存访问行为的统计信息。</li></ul><p>这两个组件通过双缓冲机制协作，确保数据采集和处理的高效性。</p><h4 id="h4-9">Collector 的工作流程</h4><p><b>(1) 数据采样</b></p><ul><li><b>采样事件</b>：<ul><li>对于读操作（load），Collector 跟踪最后一级缓存（LLC）未命中的事件（<code>MEM_LOAD_RETIRED.L3_MISS</code>）。</li></ul><ul><li>对于写操作（store），Collector 可选地跟踪 TLB 未命中的事件（<code>MEM_INST_RETIRED.STLB_MISS_STORES</code>）。</li></ul></li></ul><ul><li><b>采样数据</b>：<ul><li>每个采样记录包含以下信息：<ul><li><b>PID（进程 ID）</b>：标识产生内存访问事件的进程。</li></ul><ul><li><b>虚拟内存地址</b>：标识被访问的内存页。</li></ul></li></ul></li></ul><ul><li><b>采样频率</b>：<ul><li>默认每 200 次事件采样一次（即采样率为 1/200）。这种频率在准确性和性能开销之间取得了平衡。</li></ul><ul><li>采样率可以通过配置调整，以适应不同工作负载的需求。</li></ul></li></ul><p><b>(2) CPU 核心分组</b></p><ul><li>为了降低采样开销并提高灵活性，Collector 将所有 CPU 核心划分为多个组。</li></ul><ul><li>每隔一个短时间间隔（默认 5 秒），Collector 切换到下一组核心进行采样（称为“轮转采样”）。</li></ul><ul><li>这种轮转机制允许灵活地选择采样事件，例如：<ul><li>对于延迟敏感的应用，可以只采样一半的核心。</li></ul><ul><li>对于存储密集型应用，可以同时采样读和写的事件。</li></ul></li></ul><p><b>(3) 数据存储</b></p><ul><li>Collector 将采样数据写入两个哈希表之一。</li></ul><ul><li>每隔一分钟（默认），Collector 切换到另一个哈希表，同时唤醒 Worker 线程处理当前哈希表中的数据。</li></ul><h4 id="h4-10">Worker</h4><p><b>(1) 数据处理</b></p><ul><li>Worker 从哈希表中读取采样数据，并将其转换为虚拟页访问记录。</li></ul><ul><li>如果需要物理地址空间分析，Worker 还会将虚拟地址映射到对应的物理地址（通过 <code>/proc/$PID/pagemap</code> 接口完成）。</li></ul><ul><li>注意：物理地址转换可能会增加开销，因此对于大工作集的应用，可以选择仅分析虚拟地址空间。</li></ul><p><b>(2) 热度统计</b></p><ul><li>Worker 使用一个 64 位位图（bitmap）来跟踪每个页面的活跃性。<ul><li>如果某个页面在当前时间间隔内被访问，则对应位被置为 1。</li></ul><ul><li>每个时间间隔结束后，位图左移一位，以便为下一个时间间隔腾出空间。</li></ul><ul><li>可以通过多位来表示访问频率，但这样会缩短历史记录的时间跨度。</li></ul></li></ul><p><b>(3) 生成热图</b></p><ul><li>Worker 根据采样数据生成页面的热度分布图，包括：<ul><li>页面的访问频率（冷、温、热）。</li></ul><ul><li>页面的生命周期（存活时间）。</li></ul><ul><li>不同页面类型（匿名页、文件页等）的热度分布。</li></ul></li></ul><p><b>(4) 数据报告</b></p><ul><li>Worker 定期生成统计报告，输出到用户空间。</li></ul><ul><li>报告内容包括：<ul><li>页面热度分布。</li></ul><ul><li>不同时间段内的访问模式。</li></ul><ul><li>页面类型的敏感性分析。</li></ul></li></ul><h4 id="h4-11">工作流的双缓冲机制</h4><ul><li><b>双缓冲设计</b>：<ul><li>Collector 和 Worker 使用两个哈希表交替工作。</li></ul><ul><li>当 Collector 写入一个哈希表时，Worker 同时处理另一个哈希表中的数据。</li></ul><ul><li>这种机制避免了数据竞争，并提高了系统的效率。</li></ul></li></ul><ul><li><b>具体流程</b>：<ol start="1"><li><b>Interval N</b>：<ul><li>Collector 写入 <code>hashtable-0</code>。</li></ul><ul><li>Worker 处理 <code>hashtable-1</code> 中的数据。</li></ul></li></ol><ol start="2"><li><b>Interval N+1</b>：<ul><li>Collector 写入 <code>hashtable-1</code>。</li></ul><ul><li>Worker 处理 <code>hashtable-0</code> 中的数据。</li></ul></li></ol></li></ul><h4 id="h4-12">实际应用中的表现</h4><ul><li>Chameleon 的 CPU 开销通常在单核的 3%-5% 之间，对生产环境的影响较小。</li></ul><ul><li>在极端情况下（如高带宽敏感的工作负载），性能损失也仅为 7%。</li></ul><h3 id="h3-13">工作负载概述</h3><ul><li><b>目标</b>：<ul><li>使用 Chameleon 分析 Meta 生产服务器集群中运行的多种大型内存密集型应用。</li></ul><ul><li>这些工作负载涵盖四个不同的服务域（Web、缓存、数据仓库、广告服务），代表了数据中心中广泛的应用场景。</li></ul></li></ul><ul><li><b>典型应用</b>：<ul><li><b>Web</b>：基于虚拟机（如 HHVM 或 Python）处理 Web 请求。</li></ul><ul><li><b>缓存（Cache）</b>：分布式内存对象缓存服务，用于低延迟数据检索。</li></ul><ul><li><b>数据仓库（Data Warehouse）</b>：支持并行数据处理的统一计算引擎。</li></ul><ul><li><b>广告服务（Ads）</b>：计算密集型工作负载，结合内存数据和机器学习计算。</li></ul></li></ul><h3 id="h3-14">3.2 页面热度分布</h3><ul><li><b>主要观察</b>：<ul><li>数据中心应用中，大量分配的内存页面在其生命周期内保持“冷”状态（即不频繁访问）。</li></ul><ul><li>在两分钟的时间窗口内，Web、缓存和广告应用中仅有 <b>22%-80%</b> 的内存被频繁访问。</li></ul><ul><li>数据仓库应用中，即使其工作集可能达到 TB 级别，也只有 <b>20%</b> 的内存是热的。</li></ul></li></ul><ul><li><b>推论</b>：<ul><li>存在大量冷内存页面，可以迁移到较慢的内存层（如 CXL 内存），而不会显著影响性能。</li></ul><ul><li>分层内存系统适合这种工作负载特性。</li></ul></li></ul><h3 id="h3-15">3.3 不同页面类型的热度差异</h3><ul><li><b>匿名页 vs 文件页</b>：<ul><li>匿名页（anon pages）通常比文件页（file pages）更热。</li></ul><ul><li>在 Web 应用中，35%-60% 的匿名页是热的，而只有 3%-14% 的文件页是热的。</li></ul><ul><li>缓存应用中，匿名页主要用于查询处理，文件页则用于快速查找。尽管如此，匿名页的热度仍然高于文件页。</li></ul></li></ul><ul><li><b>推论</b>：<ul><li>匿名页更适合放置在快速本地内存中，而文件页可以优先分配到较慢的内存层。</li></ul></li></ul><h3 id="h3-16">3.4 不同页面类型随时间的变化</h3><ul><li><b>动态变化</b>：<ul><li>Web 应用启动时加载二进制文件和字节码，导致文件缓存占用大量内存；随着时间推移，匿名页逐渐增长，文件缓存被丢弃。</li></ul><ul><li>缓存应用主要依赖文件缓存进行内存查找，文件页占总内存的比例稳定在 70%-82%。</li></ul><ul><li>数据仓库应用中，匿名页占总内存的 85%，文件页仅占 15%。</li></ul></li></ul><ul><li><b>推论</b>：<ul><li>应用程序的内存使用模式虽然可能随时间变化，但总体上保持相对稳定。</li></ul><ul><li>智能页面放置机制应考虑页面类型以优化性能。</li></ul></li></ul><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67f7cbae88c538a9b5c8f7f7.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67f7cbae88c538a9b5c8f7f7.png" alt=""></a></p><h3 id="h3-17">3.5 页面类型对性能的影响</h3><ul><li><b>敏感性分析</b>：<ul><li>不同应用对匿名页和文件页的敏感性不同。</li></ul><ul><li>Web 应用的吞吐量随着匿名页利用率的提高而增加。</li></ul><ul><li>缓存应用中，tmpfs 和固定数量的匿名页对性能影响较小。</li></ul><ul><li>数据仓库应用中，匿名页的使用量与吞吐量高度相关。</li></ul></li></ul><ul><li><b>推论</b>：<ul><li>应用对不同页面类型的敏感性因工作负载而异，智能内存管理机制需要根据这些特性进行优化。</li></ul></li></ul><h3 id="h3-18">3.6 冷页面的再访问时间</h3><ul><li><b>主要观察</b>：<ul><li>冷页面往往在一段时间后被重新访问。</li></ul><ul><li>Web 和缓存应用中，约 <b>80%</b> 的冷页面在 10 分钟内被重新访问。</li></ul><ul><li>数据仓库应用中，匿名页通常是新分配的，只有 <b>20%</b> 的热文件页被重复访问。</li></ul></li></ul><ul><li><b>推论</b>：<ul><li>冷页面的再访问时间因工作负载而异。</li></ul><ul><li>分层内存系统需要主动将热页面迁移到快速内存节点，以避免高访问延迟。</li></ul></li></ul><h3 id="h3-19"><b>总结</b></h3><p>通过对数据中心应用的详细分析，作者得出了以下关键结论：</p><ol start="1"><li><b>冷页面占比高</b>：数据中心应用中存在大量冷页面，可以迁移到较慢的内存层以释放快速内存资源。</li></ol><ol start="2"><li><b>匿名页更热</b>：匿名页通常比文件页更热，且对性能更敏感。</li></ol><ol start="3"><li><b>稳定的内存使用模式</b>：尽管内存使用可能随时间变化，但大多数应用的页面使用模式相对稳定。</li></ol><ol start="4"><li><b>冷页面再访问时间的影响</b>：冷页面的再访问时间因工作负载而异，分层内存系统需要动态调整页面放置策略。</li></ol><p>这些观察结果为设计高效的分层内存管理系统（如 TPP）提供了重要依据，能够在不影响性能的情况下优化内存资源的使用。</p><h2 id="h2-20">TPP的设计原则</h2><h3 id="h3-21">实现层级的选择</h3><ul><li>TPP 被设计为内核级功能，而非用户空间工具。</li></ul><ul><li>原因：<ul><li>用户空间工具需要频繁切换上下文，增加了开销。</li></ul><ul><li>内核级实现更高效，且能更好地扩展到大规模生产环境。</li></ul></li></ul><h3 id="h3-22">页面热度检测</h3><ul><li>使用现有的 <b>LRU（Least Recently Used）机制</b> 和 <b>NUMA Balancing</b> 来检测页面热度：<ul><li>LRU：用于本地内存节点的冷页面检测，轻量且高效。</li></ul><ul><li>NUMA Balancing：仅用于 CXL-Memory 的热页面检测，避免对本地内存的干扰。</li></ul></li></ul><ul><li><b>不使用 PEBS 或其他复杂机制</b>：<ul><li>PEBS 不跨硬件平台标准化，无法作为通用解决方案。</li></ul><ul><li>页面中毒（Page Poisoning）或采样机制会引入高开销，不适合持续运行。</li></ul></li></ul><h3 id="h3-23">CXL-Memory 的抽象</h3><ul><li><b>不将 CXL-Memory 视为交换空间（swap space）</b>：<ul><li>使用交换语义会导致每次访问 CXL-Memory 时触发严重性能问题（如大页错误）。</li></ul></li></ul><ul><li><b>采用加载/存储语义</b>：<ul><li>允许应用程序直接以缓存行粒度访问 CXL-Memory，从而保持低延迟。</li></ul></li></ul><h3 id="h3-24">设计目标</h3><ul><li><b>灵活性</b>：支持异构内存技术（如 DRAM、NVM、LPDDR 等）的不同特性。</li></ul><ul><li><b>低开销</b>：通过轻量级机制实现冷页面迁移和热页面提升。</li></ul><ul><li><b>解耦分配与回收逻辑</b>：确保本地内存节点始终有足够的空闲空间，避免新分配页面被强制迁移到 CXL-Memory。</li></ul><ul><li><b>页面类型感知</b>：优先将匿名页（anon pages）分配到快速本地内存，文件页（file pages）分配到慢速 CXL-Memory。</li></ul><h2 id="h2-25">TPP的具体设计</h2><p>TPP（Transparent Page Placement）是一种智能的、操作系统级的分层内存管理机制，旨在高效地将冷页面迁移到慢速 CXL-Memory，同时识别并提升被困在慢速节点中的热页面到快速本地内存。其设计分为四个主要方面：</p><h3 id="h3-26">轻量级回收与迁移</h3><ul><li>目标 ：通过轻量级回收机制将冷页面从本地内存迁移到 CXL-Memory。</li></ul><ul><li>方法：<ul><li>使用 Linux 默认的 LRU（Least Recently Used）机制选择冷页面作为迁移候选</li></ul><ul><li>将冷页面异步迁移到 CXL-Memory，而不是使用交换机制（swap），以避免高延迟。</li></ul><ul><li>如果迁移失败（如 CXL-Memory 不足），则回退到默认回收机制。</li></ul></li></ul><ul><li>优势 ：迁移比交换快几个数量级，且不会阻塞新页面分配。</li></ul><h3 id="h3-27">分离分配与回收路径</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67f7cfb488c538a9b5c8ff26.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67f7cfb488c538a9b5c8ff26.png" alt=""></a></p><ul><li>问题 ：在多 NUMA 系统中，当本地内存不足时，新页面分配会停滞，导致更多页面被分配到 CXL-Memory。</li></ul><ul><li>解决方案 ：<ul><li>解耦分配和回收逻辑，允许在本地内存达到一定阈值（allocation_watermark）时继续分配，同时后台异步回收冷页面。</li></ul><ul><li>设置更高的 demotion_watermark，确保本地内存有足够的空闲空间。</li></ul></li></ul><ul><li>效果 ：减少因内存压力导致的性能下降，优化热页面的分配和冷页面的回收。</li></ul><h3 id="h3-28">热页面提升机制</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67f7d02b88c538a9b5c8ffe4.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67f7d02b88c538a9b5c8ffe4.png" alt=""></a></p><ul><li>问题 ：CXL-Memory 中可能包含因访问模式变化而变热的页面，若不及时提升，会影响性能。</li></ul><ul><li>解决方案 ：<ul><li>增强 NUMA Balancing 机制，仅对 CXL-Memory 进行采样，避免不必要的开销。</li></ul><ul><li>使用 LRU 列表判断页面热度，仅将活跃页面（active LRU）作为提升候选。</li></ul><ul><li>避免频繁的“乒乓效应”（ping-pong），即页面在本地内存和 CXL-Memory 之间反复迁移。</li></ul></li></ul><ul><li>优势 ：有效减少提升流量，提高页面放置效率。</li></ul><blockquote><p>NUMA平衡的基本概念</p></blockquote><p>NUMA 平衡 是一种操作系统机制，旨在通过动态调整页面的放置位置来优化内存访问性能。具体来说： 它定期采样进程的工作集（working set），以检测哪些页面被频繁访问。 如果一个页面被远程 CPU 访问，它会被迁移到该 CPU 的本地内存节点上，从而减少未来的远程内存访问延迟。</p><h3 id="h3-29">页面类型感知的分配策略</h3><ul><li>问题 ：不同类型的页面（如匿名页 anon 和文件页 file）对性能的敏感性不同。</li></ul><ul><li>解决方案 ：<ul><li>提供页面类型感知的分配策略，优先将匿名页分配到快速本地内存，文件页分配到慢速 CXL-Memory。</li></ul><ul><li>对于文件缓存（file cache），初始分配到 CXL-Memory，只有当其变热时才提升到本地内存。</li></ul></li></ul><ul><li>效果 -</li></ul><h2 id="h2-30">TPP评估</h2><h3 id="h3-31">实验设置</h3><ul><li>功能验证：在x86 CPU上部署了基于FPGA的CXL内存扩展卡，这些卡支持CXL1.1规范。当前基于FPGA的CXL卡的延迟比最终目标大约高250纳秒，使用它们进行功能验证。</li></ul><ul><li>性能评估：为评估性能，实验采用双插槽系统，模拟目标 CXL 系统（一个内存节点连接所有活动 CPU 核心，另一个为无 CPU 的内存节点）。在基线测试中，禁用一个插槽的内存和 CPU，仅使用另一个插槽的内存服务整个工作集。</li></ul><ul><li>内存配置比例：<ul><li>2:1 配置 ：本地节点内存占总内存的 2/3，接近当前生产环境。</li></ul><ul><li>1:4 配置 ：本地节点内存仅占总内存的 1/5，用于压力测试。</li></ul></li></ul><h3 id="h3-32">TPP 的有效性</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67f7d3c188c538a9b5c9044b.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67f7d3c188c538a9b5c9044b.png" alt=""></a></p><p><b>结果分析</b></p><ul><li>Web 应用 ：<ul><li>默认 Linux 内核由于冷页面未能及时迁移，导致本地节点仅服务 22% 的内存访问流量，性能下降 16.5%。</li></ul><ul><li>TPP 通过快速冷页面降级和热页面提升，使本地节点服务 90% 的内存访问流量，性能下降仅为 0.5%。</li></ul></li></ul><ul><li>缓存应用（Cache） ：<ul><li>在默认 Linux 下，部分热页面被错误分配到 CXL 节点，导致性能下降 2%-14%。</li></ul><ul><li>TPP 能有效将热匿名页（anon pages）保留在本地节点，并将冷文件页（file pages）迁移到 CXL 节点，性能接近基线。</li></ul></li></ul><ul><li>数据仓库（Data Warehouse） ：<ul><li>默认配置下，Linux 和 TPP 性能相近，因为大部分热页面已驻留在本地节点。</li></ul><ul><li>TPP 进一步优化了热页面分布，使本地节点的内存访问流量增加 4%。</li></ul></li></ul><ul><li>极端扩展场景（1:4 配置） ：<ul><li>在 Cache 应用中，TPP 能将 80%-97% 的热匿名页迁移到本地节点，性能下降仅为 0.5%-5%。</li></ul><ul><li>相比之下，AutoTiering 和 NUMA Balancing 表现较差，甚至在某些情况下无法运行。</li></ul></li></ul><h3 id="h3-33">TPP 组件的影响</h3><ul><li><b>分配与回收解耦</b>：<ul><li>解耦机制允许本地节点保持足够的空闲空间以应对突发分配需求。</li></ul><ul><li>未解耦时，新分配页面经常被放置到 CXL 节点，导致性能下降 12%。</li></ul><ul><li>解耦后，本地节点的内存访问流量增加 15%，吞吐量提高 2.4%。</li></ul></li></ul><ul><li><b>基于 LRU 的热页面检测</b>：<ul><li>仅将活跃 LRU 页面作为提升候选，减少了不必要的页面迁移。</li></ul><ul><li>页面迁移率降低 11 倍，成功提升率提高 48%。</li></ul></li></ul><ul><li><b>页面类型感知的分配策略</b>：<ul><li>对 Web 和 Cache 应用，优先将文件缓存分配到 CXL 节点，显著减少本地节点的压力。</li></ul><ul><li>吞吐量接近基线，性能下降仅为 0.2%-2.5%。</li></ul></li></ul><h3 id="h3-34">与现有解决方案的对比</h3><ul><li><b>NUMA Balancing</b>：<ul><li>在内存压力下，NUMA Balancing 的页面提升率较慢（比 TPP 慢 11 倍），导致性能下降 10%-17%。</li></ul><ul><li>TPP 在 1:4 配置下表现优于 NUMA Balancing，即使本地节点容量更小。</li></ul></li></ul><ul><li><b>AutoTiering</b>：<ul><li>AutoTiering 在高内存压力下容易崩溃，无法处理 1:4 配置。</li></ul><ul><li>即使在 2:1 配置下，TPP 比 AutoTiering 提供更高的本地节点流量（多 10%），吞吐量提升 7%。</li></ul></li></ul><ul><li><b>TMO（Transparent Memory Offloading）</b>：<ul><li>TMO 主要通过交换机制回收内存，但无法直接利用 CXL-Memory 的加载/存储语义。</li></ul><ul><li>结合 TPP 和 TMO 可进一步优化性能：TPP 提供两级降级机制，使 TMO 的内存回收效率提高 3%，同时减少进程阻塞。</li></ul></li></ul><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67f7d48188c538a9b5c9054c.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67f7d48188c538a9b5c9054c.png" alt=""></a></p><h3 id="h3-35"><b>总结</b></h3><p>TPP 在多种工作负载和内存配置下表现出色：</p><ul><li>在默认生产环境（2:1 配置）中，TPP 将性能损失控制在 0.5% 以内。</li></ul><ul><li>在极端扩展场景（1:4 配置）中，TPP 显著优于现有解决方案，性能接近理想基线。</li></ul><ul><li>通过高效的冷页面降级、热页面提升以及页面类型感知的分配策略，TPP 在分层内存系统中实现了低延迟和高吞吐量。</li></ul><h2 id="h2-36">结论</h2><p>使用Chameleon分析了数据中心应用程序的内存使用行为，以找到支持CXL的分层内存系统的适用范围。为了实现这样的系统，我们设计了TPP，这是一种无需事先了解应用程序内存访问行为的操作系统级别的透明页面放置机制。我们使用各种生产工作负载评估了TPP，发现TPP将应用程序在默认Linux上的性能提高了18%。TPP还优于NUMA平衡和AutoTiering这两种最先进的分层内存管理机制，性能提升了5-17%。</p></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../内存池化/Pond" >内存池化</a><ul><li><a href="../../内存池化/Pond" >Pond</a></li></ul></li></ul><ul><li><a href="../../内存分级/TPP" >内存分级</a><ul><li><a href="../../内存分级/TPP" >TPP</a></li></ul></li></ul><ul><li><a href="../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices" >带宽与延迟</a><ul><li><a href="../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices" >Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices</a></li></ul></li></ul><ul><li><a href="../../CXL-SSD/Hello_Bytes" >CXL-SSD</a><ul><li><a href="../../CXL-SSD/Hello_Bytes" >Hello_Bytes</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../内存池化/Pond","../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>