<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/IcarusSong/cxl-papers.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">TPP</a><ul><li><a href="#h2-1">内存分层出现背景</a></li></ul><ul><li><a href="#h2-2">内存分层带来的影响</a></li></ul><ul><li><a href="#h2-3">数据中心应用的特征分析</a><ul><li><a href="#h3-4">Chameleon介绍</a></li></ul><ul><li><a href="#h3-5">Chameleon 的工作流程</a><ul><li><a href="#h4-6">Collector 的工作流程</a></li></ul><ul><li><a href="#h4-7">Worker</a></li></ul><ul><li><a href="#h4-8">工作流的双缓冲机制</a></li></ul><ul><li><a href="#h4-9">实际应用中的表现</a></li></ul></li></ul><ul><li><a href="#h3-10">工作负载概述</a></li></ul><ul><li><a href="#h3-11">3.2 页面热度分布</a></li></ul><ul><li><a href="#h3-12">3.3 不同页面类型的热度差异</a></li></ul><ul><li><a href="#h3-13">3.4 不同页面类型随时间的变化</a></li></ul><ul><li><a href="#h3-14">3.5 页面类型对性能的影响</a></li></ul><ul><li><a href="#h3-15">3.6 冷页面的再访问时间</a></li></ul><ul><li><a href="#h3-16">总结</a></li></ul></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">TPP</h1><p>内存拓展成本-》DRAM内存技术通过构建分层内存子系统和以更低的成本/GB点添加更高的内存容量-》从延迟和带宽来看CXL是个好选择-》内存分层是是否有益呢？-》需要了解数据中心应用的行为-》观察不同应用特点-》四个观察-》设计TPP-》TPP机制-》TPP实现-》TPP效果-》未来展望</p><h2 id="h2-1">内存分层出现背景</h2><p>在数据中心中，应用对内存的需求激增，由于增加DRAM带来的高额成本以及拓展内存带来的技术挑战，使得内存成为超大规模数据中心基础设置支出的重要部分，微软表示，50%的服务器总成本来自DRAM。 <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67f7bd2688c538a9b5c8dd76.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67f7bd2688c538a9b5c8dd76.png" alt=""></a> 可以利用程序局部性，进行存储分层，利用高速存储的延迟和低俗内存的容量，降低数据中心的内存成本。</p><p>在CXL之前的内存分层技术（PCIe、RDMA），相较于主存而言，都有更高的延迟，在数据在不同层级的内存层次结构中分配不当时，会造成严重的性能损失。</p><p>CXL的出现解决了这一问题，既解决了非DRAM内存的高延迟问题，又保留了类似 DRAM 的高带宽和细粒度访问能力。 <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67f7bb8188c538a9b5c8da2a.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67f7bb8188c538a9b5c8da2a.png" alt=""></a> <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67f7bb9588c538a9b5c8da69.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67f7bb9588c538a9b5c8da69.png" alt=""></a></p><h2 id="h2-2">内存分层带来的影响</h2><p>为了测试内存分层是否有意，需要了解数据中心中各类应用的内存访问行为。对于每个应用，需要了解其内存中有多少在特定时间段内保持<b>热、温或冷</b>，以及有多少内存是短期的，或者是长期的。</p><p>现有的基于空闲页面跟踪（IPT）的工具无法满足需求，原因包括以下几点：</p><ol start="1"><li><b>内核修改限制</b>：这些工具需要对内核进行修改，这在生产环境中通常是不可行的。</li></ol><ol start="2"><li><b>高资源开销</b>：持续的访问位采样和分析会导致过高的CPU和内存开销，难以扩展到大工作集。</li></ol><ol start="3"><li><b>缺乏页类型敏感性</b>：应用程序对不同类型内存页（如匿名页、文件页缓存、共享内存等）的敏感性不同，而现有工具未能考虑这一点。</li></ol><h2 id="h2-3">数据中心应用的特征分析</h2><p>作者通过开发 <b>Chameleon</b> 工具对数据中心应用的内存使用行为进行了详细分析。Chameleon 是一种轻量级的用户空间工具，能够高效地表征应用程序的内存访问模式，而无需修改内核或干扰生产环境中的运行应用。</p><h3 id="h3-4">Chameleon介绍</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67f7c71a88c538a9b5c8ef94.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67f7c71a88c538a9b5c8ef94.png" alt=""></a></p><h3 id="h3-5">Chameleon 的工作流程</h3><p>Chameleon是一种轻量级的用户空间工具，用于表征数据中心应用程序的内存访问行为。它通过硬件性能事件采样（PEBS）机制来生成应用程序的内存访问热图，并帮助分析不同页面类型的热度分布。以下是其工作流程的详细说明：</p><p>Chameleon 的设计目标是：</p><ul><li>在不影响生产环境运行的情况下快速部署。</li></ul><ul><li>提供低开销的内存访问行为分析。</li></ul><ul><li>支持对虚拟地址空间和物理地址空间的分析。</li></ul><p>为实现这些目标，Chameleon 由两个主要组件组成，分别运行在不同的线程中：</p><ul><li><b>Collector（收集器）</b>：负责从硬件性能计数器中采样内存访问事件。</li></ul><ul><li><b>Worker（处理线程）</b>：负责处理采样数据并生成内存访问行为的统计信息。</li></ul><p>这两个组件通过双缓冲机制协作，确保数据采集和处理的高效性。</p><h4 id="h4-6">Collector 的工作流程</h4><p><b>(1) 数据采样</b></p><ul><li><b>采样事件</b>：<ul><li>对于读操作（load），Collector 跟踪最后一级缓存（LLC）未命中的事件（<code>MEM_LOAD_RETIRED.L3_MISS</code>）。</li></ul><ul><li>对于写操作（store），Collector 可选地跟踪 TLB 未命中的事件（<code>MEM_INST_RETIRED.STLB_MISS_STORES</code>）。</li></ul></li></ul><ul><li><b>采样数据</b>：<ul><li>每个采样记录包含以下信息：<ul><li><b>PID（进程 ID）</b>：标识产生内存访问事件的进程。</li></ul><ul><li><b>虚拟内存地址</b>：标识被访问的内存页。</li></ul></li></ul></li></ul><ul><li><b>采样频率</b>：<ul><li>默认每 200 次事件采样一次（即采样率为 1/200）。这种频率在准确性和性能开销之间取得了平衡。</li></ul><ul><li>采样率可以通过配置调整，以适应不同工作负载的需求。</li></ul></li></ul><p><b>(2) CPU 核心分组</b></p><ul><li>为了降低采样开销并提高灵活性，Collector 将所有 CPU 核心划分为多个组。</li></ul><ul><li>每隔一个短时间间隔（默认 5 秒），Collector 切换到下一组核心进行采样（称为“轮转采样”）。</li></ul><ul><li>这种轮转机制允许灵活地选择采样事件，例如：<ul><li>对于延迟敏感的应用，可以只采样一半的核心。</li></ul><ul><li>对于存储密集型应用，可以同时采样读和写的事件。</li></ul></li></ul><p><b>(3) 数据存储</b></p><ul><li>Collector 将采样数据写入两个哈希表之一。</li></ul><ul><li>每隔一分钟（默认），Collector 切换到另一个哈希表，同时唤醒 Worker 线程处理当前哈希表中的数据。</li></ul><h4 id="h4-7">Worker</h4><p><b>(1) 数据处理</b></p><ul><li>Worker 从哈希表中读取采样数据，并将其转换为虚拟页访问记录。</li></ul><ul><li>如果需要物理地址空间分析，Worker 还会将虚拟地址映射到对应的物理地址（通过 <code>/proc/$PID/pagemap</code> 接口完成）。</li></ul><ul><li>注意：物理地址转换可能会增加开销，因此对于大工作集的应用，可以选择仅分析虚拟地址空间。</li></ul><p><b>(2) 热度统计</b></p><ul><li>Worker 使用一个 64 位位图（bitmap）来跟踪每个页面的活跃性。<ul><li>如果某个页面在当前时间间隔内被访问，则对应位被置为 1。</li></ul><ul><li>每个时间间隔结束后，位图左移一位，以便为下一个时间间隔腾出空间。</li></ul><ul><li>可以通过多位来表示访问频率，但这样会缩短历史记录的时间跨度。</li></ul></li></ul><p><b>(3) 生成热图</b></p><ul><li>Worker 根据采样数据生成页面的热度分布图，包括：<ul><li>页面的访问频率（冷、温、热）。</li></ul><ul><li>页面的生命周期（存活时间）。</li></ul><ul><li>不同页面类型（匿名页、文件页等）的热度分布。</li></ul></li></ul><p><b>(4) 数据报告</b></p><ul><li>Worker 定期生成统计报告，输出到用户空间。</li></ul><ul><li>报告内容包括：<ul><li>页面热度分布。</li></ul><ul><li>不同时间段内的访问模式。</li></ul><ul><li>页面类型的敏感性分析。</li></ul></li></ul><h4 id="h4-8">工作流的双缓冲机制</h4><ul><li><b>双缓冲设计</b>：<ul><li>Collector 和 Worker 使用两个哈希表交替工作。</li></ul><ul><li>当 Collector 写入一个哈希表时，Worker 同时处理另一个哈希表中的数据。</li></ul><ul><li>这种机制避免了数据竞争，并提高了系统的效率。</li></ul></li></ul><ul><li><b>具体流程</b>：<ol start="1"><li><b>Interval N</b>：<ul><li>Collector 写入 <code>hashtable-0</code>。</li></ul><ul><li>Worker 处理 <code>hashtable-1</code> 中的数据。</li></ul></li></ol><ol start="2"><li><b>Interval N+1</b>：<ul><li>Collector 写入 <code>hashtable-1</code>。</li></ul><ul><li>Worker 处理 <code>hashtable-0</code> 中的数据。</li></ul></li></ol></li></ul><h4 id="h4-9">实际应用中的表现</h4><ul><li>Chameleon 的 CPU 开销通常在单核的 3%-5% 之间，对生产环境的影响较小。</li></ul><ul><li>在极端情况下（如高带宽敏感的工作负载），性能损失也仅为 7%。</li></ul><h3 id="h3-10">工作负载概述</h3><ul><li><b>目标</b>：<ul><li>使用 Chameleon 分析 Meta 生产服务器集群中运行的多种大型内存密集型应用。</li></ul><ul><li>这些工作负载涵盖四个不同的服务域（Web、缓存、数据仓库、广告服务），代表了数据中心中广泛的应用场景。</li></ul></li></ul><ul><li><b>典型应用</b>：<ul><li><b>Web</b>：基于虚拟机（如 HHVM 或 Python）处理 Web 请求。</li></ul><ul><li><b>缓存（Cache）</b>：分布式内存对象缓存服务，用于低延迟数据检索。</li></ul><ul><li><b>数据仓库（Data Warehouse）</b>：支持并行数据处理的统一计算引擎。</li></ul><ul><li><b>广告服务（Ads）</b>：计算密集型工作负载，结合内存数据和机器学习计算。</li></ul></li></ul><h3 id="h3-11">3.2 页面热度分布</h3><ul><li><b>主要观察</b>：<ul><li>数据中心应用中，大量分配的内存页面在其生命周期内保持“冷”状态（即不频繁访问）。</li></ul><ul><li>在两分钟的时间窗口内，Web、缓存和广告应用中仅有 <b>22%-80%</b> 的内存被频繁访问。</li></ul><ul><li>数据仓库应用中，即使其工作集可能达到 TB 级别，也只有 <b>20%</b> 的内存是热的。</li></ul></li></ul><ul><li><b>推论</b>：<ul><li>存在大量冷内存页面，可以迁移到较慢的内存层（如 CXL 内存），而不会显著影响性能。</li></ul><ul><li>分层内存系统适合这种工作负载特性。</li></ul></li></ul><h3 id="h3-12">3.3 不同页面类型的热度差异</h3><ul><li><b>匿名页 vs 文件页</b>：<ul><li>匿名页（anon pages）通常比文件页（file pages）更热。</li></ul><ul><li>在 Web 应用中，35%-60% 的匿名页是热的，而只有 3%-14% 的文件页是热的。</li></ul><ul><li>缓存应用中，匿名页主要用于查询处理，文件页则用于快速查找。尽管如此，匿名页的热度仍然高于文件页。</li></ul></li></ul><ul><li><b>推论</b>：<ul><li>匿名页更适合放置在快速本地内存中，而文件页可以优先分配到较慢的内存层。</li></ul></li></ul><h3 id="h3-13">3.4 不同页面类型随时间的变化</h3><ul><li><b>动态变化</b>：<ul><li>Web 应用启动时加载二进制文件和字节码，导致文件缓存占用大量内存；随着时间推移，匿名页逐渐增长，文件缓存被丢弃。</li></ul><ul><li>缓存应用主要依赖文件缓存进行内存查找，文件页占总内存的比例稳定在 70%-82%。</li></ul><ul><li>数据仓库应用中，匿名页占总内存的 85%，文件页仅占 15%。</li></ul></li></ul><ul><li><b>推论</b>：<ul><li>应用程序的内存使用模式虽然可能随时间变化，但总体上保持相对稳定。</li></ul><ul><li>智能页面放置机制应考虑页面类型以优化性能。</li></ul></li></ul><h3 id="h3-14">3.5 页面类型对性能的影响</h3><ul><li><b>敏感性分析</b>：<ul><li>不同应用对匿名页和文件页的敏感性不同。</li></ul><ul><li>Web 应用的吞吐量随着匿名页利用率的提高而增加。</li></ul><ul><li>缓存应用中，tmpfs 和固定数量的匿名页对性能影响较小。</li></ul><ul><li>数据仓库应用中，匿名页的使用量与吞吐量高度相关。</li></ul></li></ul><ul><li><b>推论</b>：<ul><li>应用对不同页面类型的敏感性因工作负载而异，智能内存管理机制需要根据这些特性进行优化。</li></ul></li></ul><h3 id="h3-15">3.6 冷页面的再访问时间</h3><ul><li><b>主要观察</b>：<ul><li>冷页面往往在一段时间后被重新访问。</li></ul><ul><li>Web 和缓存应用中，约 <b>80%</b> 的冷页面在 10 分钟内被重新访问。</li></ul><ul><li>数据仓库应用中，匿名页通常是新分配的，只有 <b>20%</b> 的热文件页被重复访问。</li></ul></li></ul><ul><li><b>推论</b>：<ul><li>冷页面的再访问时间因工作负载而异。</li></ul><ul><li>分层内存系统需要主动将热页面迁移到快速内存节点，以避免高访问延迟。</li></ul></li></ul><h3 id="h3-16"><b>总结</b></h3><p>通过对数据中心应用的详细分析，作者得出了以下关键结论：</p><ol start="1"><li><b>冷页面占比高</b>：数据中心应用中存在大量冷页面，可以迁移到较慢的内存层以释放快速内存资源。</li></ol><ol start="2"><li><b>匿名页更热</b>：匿名页通常比文件页更热，且对性能更敏感。</li></ol><ol start="3"><li><b>稳定的内存使用模式</b>：尽管内存使用可能随时间变化，但大多数应用的页面使用模式相对稳定。</li></ol><ol start="4"><li><b>冷页面再访问时间的影响</b>：冷页面的再访问时间因工作负载而异，分层内存系统需要动态调整页面放置策略。</li></ol><p>这些观察结果为设计高效的分层内存管理系统（如 TPP）提供了重要依据，能够在不影响性能的情况下优化内存资源的使用。</p></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../内存池化/Pond" >内存池化</a><ul><li><a href="../../内存池化/Pond" >Pond</a></li></ul></li></ul><ul><li><a href="../../内存分级/TPP" >内存分级</a><ul><li><a href="../../内存分级/TPP" >TPP</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../内存池化/Pond",".","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>