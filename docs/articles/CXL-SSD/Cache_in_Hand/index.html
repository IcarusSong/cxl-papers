<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/IcarusSong/cxl-papers.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">Cache in Hand: Expander-Driven CXL Prefetcher for Next Generation CXL-SSDs</a><ul><li><a href="#h2-1">作者以及出版物</a><ul><li><a href="#h3-2">作者</a></li></ul><ul><li><a href="#h3-3">出版物</a></li></ul></li></ul><ul><li><a href="#h2-4">一、CXL-SSD的架构意义与核心挑战</a><ul><li><a href="#h3-5">1. 内存解耦与CXL协议的革命性</a></li></ul><ul><li><a href="#h3-6">2. 局部性对CXL-SSD性能的致命影响</a></li></ul></li></ul><ul><li><a href="#h2-7">二、ExPAND的设计哲学：扩展器驱动的协同预取</a><ul><li><a href="#h3-8">1. 核心思想：卸载、协作与感知</a></li></ul><ul><li><a href="#h3-9">2. 系统架构：反射器与决策器的双向协同</a></li></ul><ul><li><a href="#h3-10">3. 协议层创新：CXL.mem的增强利用</a></li></ul><ul><li><a href="#h3-11">4. 预取及时性（Prefetch Timeliness）</a></li></ul></li></ul><ul><li><a href="#h2-12">三、性能评测：突破性优势与鲁棒性验证</a><ul><li><a href="#h3-13">1. 实验设置</a></li></ul><ul><li><a href="#h3-14">2. 关键结果</a></li></ul><ul><li><a href="#h3-15">3. 技术突破点</a></li></ul></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">Cache in Hand: Expander-Driven CXL Prefetcher for Next Generation CXL-SSDs</h1><h2 id="h2-1">作者以及出版物</h2><h3 id="h3-2">作者</h3><p>Miryeong Kwon, Sangwon Lee, Myoungsoo Jung <b>KAIST</b></p><h3 id="h3-3">出版物</h3><p>HotStorage ’23</p><h2 id="h2-4"><b>一、CXL-SSD的架构意义与核心挑战</b></h2><h3 id="h3-5"><b>1. 内存解耦与CXL协议的革命性</b></h3><p>随着云计算、AI训练和大规模图计算等应用对内存容量需求的爆炸式增长，传统DRAM受限于物理密度和成本，难以满足TB级内存扩展需求。<b>Compute Express Link (CXL)</b> 协议通过内存解耦（Memory Disaggregation）技术，将存储类内存（SCM）设备（如PRAM、Z-NAND、XL-Flash）整合为可扩展的内存池（CXL-SSD），使主机CPU能够以内存语义（Load/Store指令）直接访问远端存储设备。这一架构的革新性体现在两方面：</p><ul><li><b>容量经济性</b>：SCM的存储密度显著高于DRAM（例如，XL-Flash的Die堆叠层数可达96层），单位成本降低50%以上。</li></ul><ul><li><b>协议高效性</b>：CXL基于PCIe物理层，支持缓存一致性（CXL.cache）与内存语义访问（CXL.mem），延迟较传统NVMe降低90%（从μs级降至ns级）。</li></ul><p>然而，CXL-SSD的<b>后端介质速度缺陷</b>成为性能瓶颈：</p><ul><li><b>PRAM</b>的读取延迟为DRAM的7倍（约140ns vs. 20ns）。</li></ul><ul><li><b>Z-NAND</b>等新型闪存的读取延迟高达DRAM的30倍（600ns）。</li></ul><h3 id="h3-6"><b>2. 局部性对CXL-SSD性能的致命影响</b></h3><p>内存访问的<b>时间局部性（Temporal Locality）</b>与<b>空间局部性（Spatial Locality）</b>直接决定CXL-SSD的有效性。原文通过合成测试量化了局部性水平的影响（图1）： <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67fe4fe288c538a9b5d1d558.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67fe4fe288c538a9b5d1d558.png" alt=""></a></p><ul><li><b>低局部性场景（α=0.1~1，L=4~16）</b>：<ul><li>CXL-SSD的平均延迟比本地DRAM（LocalDRAM）高738%，性能差距主要源于后端SCM的频繁访问。</li></ul><ul><li>此类场景常见于<b>图遍历（BFS）</b>、<b>稀疏矩阵计算</b>等不规则访问模式，缓存命中率低于20%。</li></ul></li></ul><ul><li><b>高局部性场景（α≤0.01，L≥16）</b>：<ul><li>CXL-SSD的延迟仅比LocalDRAM高35%，性能接近DRAM。</li></ul><ul><li>连续访问或循环访问模式下，数据可被LLC或SSD内部DRAM缓存捕获，后端访问频率降低80%以上。</li></ul></li></ul><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67fe512c88c538a9b5d1d6a3.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67fe512c88c538a9b5d1d6a3.png" alt=""></a> 实验表明，<b>提升缓存命中率是优化CXL-SSD性能的核心路径</b>，但现有方案存在两大缺陷：</p><ol start="1"><li><b>工业界PoC的局限性</b>：<ul><li>SSD侧DRAM缓存（如三星16GB Z-NAND方案）仅优化写入路径，随机读取仍需穿透至SCM。</li></ul><ul><li>传统预取器（如流式预取）依赖固定步长规则，对不规则模式预测准确率不足30%。</li></ul></li></ol><ol start="2"><li><b>CXL网络拓扑复杂性</b>：<ul><li>CXL 3.0的<b>多层级交换架构（Multi-tiered Switching）</b>引入端到端延迟波动（每增加1层交换机，延迟上升1%）。</li></ul><ul><li>现有预取器因缺乏拓扑感知能力，无法动态调整预取时机，导致数据提前失效或延迟到达（图2b）。</li></ul></li></ol><h2 id="h2-7"><b>二、ExPAND的设计哲学：扩展器驱动的协同预取</b></h2><h3 id="h3-8"><b>1. 核心思想：卸载、协作与感知</b></h3><p>ExPAND（Expander-Driven CXL Prefetcher）通过三大创新突破性能瓶颈：</p><ul><li><b>任务卸载</b>：将LLC预取逻辑从CPU转移至CXL-SSD，利用SSD端计算资源运行复杂预测模型。</li></ul><ul><li><b>协议协作</b>：利用CXL 3.0的<b>回传失效（Back-Invalidation, BI）</b>机制实现缓存一致性，避免CXL.cache的高开销。</li></ul><ul><li><b>拓扑感知</b>：动态识别CXL交换机层级，为每个设备定制端到端延迟模型。</li></ul><h3 id="h3-9"><b>2. 系统架构：反射器与决策器的双向协同</b></h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67fe515088c538a9b5d1d6c5.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67fe515088c538a9b5d1d6c5.png" alt=""></a></p><ul><li><b>反射器（Reflector）</b>：<ul><li><b>功能定位</b>：集成于主机CXL根复合体（Root Complex），作为预取数据的临时缓冲区（16KB）。</li></ul><ul><li><b>拓扑发现</b>：在PCIe枚举阶段，通过总线号解析CXL交换机层级，计算每个CXL-SSD的端到端延迟。</li></ul><ul><li><b>延迟注入</b>：将计算后的延迟值写入设备配置空间（PCIe DOE字段），供SSD侧决策器调用。</li></ul></li></ul><ul><li><b>决策器（Decider）</b>：<ul><li><b>地址预测</b>：采用多模态Transformer模型，融合程序计数器（PC）与内存地址序列，预测未来访问模式。<ul><li><b>多模态注意力机制</b>：分析PC（标识代码阶段）与地址序列（反映数据布局）的关联性。</li></ul><ul><li><b>动态适应</b>：通过在线决策树分类器（80B元数据）监测应用行为变化，调整预测策略。</li></ul></li></ul><ul><li><b>时间预测</b>：基于滑动窗口平均法估计请求到达时间，结合拓扑延迟计算预取触发点。</li></ul></li></ul><h3 id="h3-10"><b>3. 协议层创新：CXL.mem的增强利用</b></h3><ul><li><b>下行通信（Host→SSD）</b>：<ul><li>通过自定义操作码<code>MemRdPC</code>，在内存读请求中携带PC信息，为SSD提供代码上下文。</li></ul></li></ul><ul><li><b>上行通信（SSD→Host）</b>：<ul><li>利用<code>BISnpData</code>操作码回传预取数据，绕过传统DMA机制，直接更新LLC缓冲区。</li></ul><ul><li><b>回传失效（BI）</b>：SSD可主动失效主机缓存行，确保数据一致性，避免冗余访问。</li></ul></li></ul><h3 id="h3-11"><b>4. 预取及时性（Prefetch Timeliness）</b></h3><p>ExPAND的核心优化目标是通过精准的时序控制，平衡“预取过早”（缓存污染）与“预取过晚”（延迟暴露）的矛盾：</p><ul><li><b>计算公式</b>：</li></ul><ul><li><b>动态调整</b>：在4层拓扑下，ExPAND通过延迟补偿将缓存污染率控制在5%以内。</li></ul><h2 id="h2-12"><b>三、性能评测：突破性优势与鲁棒性验证</b></h2><h3 id="h3-13"><b>1. 实验设置</b></h3><ul><li><b>仿真平台</b>：基于gem5+SimpleSSD构建全系统模型，集成CXL RTL模块验证功能正确性。</li></ul><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67fe522288c538a9b5d1d80a.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67fe522288c538a9b5d1d80a.png" alt=""></a></p><ul><li><b>工作负载</b>：4种图算法（BFS、Connected Components、PageRank、Triangle Counting），数据集为Amazon商品共购网络（百万级节点）。</li></ul><ul><li><b>对比基线</b>：无预取（NoPrefetch）、规则型预取（Rule1/Rule2）、ML预取（LSTM/Transformer）。</li></ul><h3 id="h3-14"><b>2. 关键结果</b></h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67fe517988c538a9b5d1d6ea.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67fe517988c538a9b5d1d6ea.png" alt=""></a></p><ul><li><b>加速比优势</b>：<ul><li>ExPAND相比无预取基线提升<b>3.5倍</b>，优于规则型（2.1倍）与ML预取（1.5倍）。</li></ul><ul><li>在BFS算法中，因模型精准预测子节点序列，LLC命中率从28%提升至92%。</li></ul></li></ul><ul><li><b>拓扑鲁棒性</b>：<ul><li>在4层交换机拓扑下，ExPAND仍保持<b>4.1倍加速比</b>，性能衰减仅0.2%/层级。</li></ul><ul><li>传统预取器因未感知延迟波动，性能下降1%/层级（如PageRank在4层下延迟增加4%）。</li></ul></li></ul><ul><li><b>资源开销</b>：<ul><li>反射器缓冲区仅占16KB主机内存，决策器模型参数压缩至128维，SSD端计算延迟增加不足1μs。</li></ul></li></ul><h3 id="h3-15"><b>3. 技术突破点</b></h3><ul><li><b>机器学习与硬件协同</b>：首次在SSD控制器部署Transformer模型，突破CPU侧存储限制。</li></ul><ul><li><b>协议层深度定制</b>：通过<code>BISnpData</code>与<code>MemRdPC</code>实现零拷贝数据更新，通信开销降低70%。</li></ul><ul><li><b>全局拓扑感知</b>：动态适应多层级CXL网络，为异构内存池提供统一优化框架。</li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../内存池化/Pond" >内存池化</a><ul><li><a href="../../内存池化/Pond" >Pond</a></li></ul><ul><li><a href="../../内存池化/Direct_CXL" >Direct_CXL</a></li></ul><ul><li><a href="../../内存池化/Against_CXL_Memory_Pooling" >Against_CXL_Memory_Pooling</a></li></ul><ul><li><a href="../../内存池化/Logical Memory Pools:  Flexible and Local Disaggregated Memory" >Logical Memory Pools:  Flexible and Local Disaggregated Memory</a></li></ul><ul><li><a href="../../内存池化/STARNUMA: Mitigating NUMA Challenges with Memory Pooling" >STARNUMA: Mitigating NUMA Challenges with Memory Pooling</a></li></ul><ul><li><a href="../../内存池化/Performance Evaluation on CXL-enabled Hybrid  Memory Pool" >Performance Evaluation on CXL-enabled Hybrid  Memory Pool</a></li></ul><ul><li><a href="../../内存池化/Memory Sharing with CXL: Hardware and Software Design Approaches" >Memory Sharing with CXL: Hardware and Software Design Approaches</a></li></ul></li></ul><ul><li><a href="../../内存分级/TPP" >内存分级</a><ul><li><a href="../../内存分级/TPP" >TPP</a></li></ul><ul><li><a href="../../内存分级/NeoMem" >NeoMem</a></li></ul></li></ul><ul><li><a href="../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices" >带宽与延迟</a><ul><li><a href="../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices" >Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices</a></li></ul><ul><li><a href="../../带宽与延迟/Systematic CXL Memory Characterization and  Performance Analysis at Scale" >Systematic CXL Memory Characterization and  Performance Analysis at Scale</a></li></ul></li></ul><ul><li><a href="../../CXL-SSD/Hello_Bytes" >CXL-SSD</a><ul><li><a href="../../CXL-SSD/Hello_Bytes" >Hello_Bytes</a></li></ul><ul><li><a href="../../CXL-SSD/Cache_in_Hand" >Cache_in_Hand</a></li></ul></li></ul><ul><li><a href="../../simulation/CXL-DMsim" >simulation</a><ul><li><a href="../../simulation/CXL-DMsim" >CXL-DMsim</a></li></ul></li></ul><ul><li><a href="../../CXL探索/Enhanced_Memory_Functions" >CXL探索</a><ul><li><a href="../../CXL探索/Enhanced_Memory_Functions" >Enhanced_Memory_Functions</a></li></ul></li></ul><ul><li><a href="../../内存拓展/Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller" >内存拓展</a><ul><li><a href="../../内存拓展/Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller" >Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller</a></li></ul><ul><li><a href="../../内存拓展/Accelerating_Performance_of_GPU-based_Workloads_Using_CXL" >Accelerating_Performance_of_GPU-based_Workloads_Using_CXL</a></li></ul></li></ul><ul><li><a href="../../Prefetch/Polaris: Enhancing CXL-based Memory Expanders with Memory-side Prefetching" >Prefetch</a><ul><li><a href="../../Prefetch/Polaris: Enhancing CXL-based Memory Expanders with Memory-side Prefetching" >Polaris: Enhancing CXL-based Memory Expanders with Memory-side Prefetching</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../CXL-SSD/Hello_Bytes","../../simulation/CXL-DMsim","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>