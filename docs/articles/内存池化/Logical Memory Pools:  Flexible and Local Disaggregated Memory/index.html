<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/IcarusSong/cxl-papers.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">Logical Memory Pools:  Flexible and Local Disaggregated Memory</a><ul><li><a href="#h2-1">作者及出版物</a><ul><li><a href="#h3-2">作者</a></li></ul><ul><li><a href="#h3-3">出版物</a></li></ul></li></ul><ul><li><a href="#h2-4">文章背景</a></li></ul><ul><li><a href="#h2-5">相关工作以及局限性</a></li></ul><ul><li><a href="#h2-6">论文发现以及论文贡献</a></li></ul><ul><li><a href="#h2-7">方法策略</a></li></ul><ul><li><a href="#h2-8">实验设置与实验结果</a></li></ul><ul><li><a href="#h2-9">前提假设与局限性</a></li></ul><ul><li><a href="#h2-10">物理池和逻辑池的对比</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">Logical Memory Pools:  Flexible and Local Disaggregated Memory</h1><h2 id="h2-1">作者及出版物</h2><h3 id="h3-2">作者</h3><ul><li><b>Emmanuel Amaro</b>: VMware Research</li></ul><ul><li><b>Stephanie Wang</b>: 加州大学伯克利分校 (UC Berkeley)</li></ul><ul><li><b>Aurojit Panda</b>: 纽约大学 (NYU)</li></ul><ul><li><b>Marcos K. Aguilera</b>: VMware Research</li></ul><h3 id="h3-3">出版物</h3><p>HotNets ’23, November 28–29, 2023, Cambridge, MA, USA</p><h2 id="h2-4">文章背景</h2><p>该研究的背景是数据中心对内存资源日益增长的需求以及对更高资源利用率和更低拥有成本的追求。传统的服务器架构将计算和内存紧密耦合，导致内存资源无法在不同服务器间共享，造成了资源浪费。为了解决这个问题，“内存分离”（Memory Disaggregation）技术应运而生，它旨在将内存汇集成一个可由多个服务器访问的共享池。早期的内存分离方案多基于软件实现（例如，使用RDMA），但这些方案因为需要软件显式发出IO请求，延迟较高且CPU开销大。随着新兴的CXL（Compute Express Link）技术获得广泛的行业支持，基于硬件的内存分离成为可能。CXL允许处理器通过PCIe总线直接以“加载-存储”（load-store）的方式访问外部内存，这种方式延迟更低、开销更小。当前基于CXL的内存分离方案主要集中在物理内存池（Physical Memory Pools）上，即创建一个与服务器物理上分离的、独立的内存设备池。这篇论文正是在此背景下，对物理内存池方案提出挑战，并提出了一种新的架构。</p><h2 id="h2-5">相关工作以及局限性</h2><p>文章主要针对两种现有的内存分离方法，并指出了它们的局限性：</p><ul><li><b>软件内存分离 (Software Memory Disaggregation)</b>: 这类工作通过RDMA等技术实现远程内存访问。<ul><li><b>局限性</b>: 访问内存需要软件（应用库或操作系统）发起IO请求，并通过网络堆栈处理完成，整个过程缓慢且与CPU的流水线、乱序执行、预取等架构特性不匹配，导致CPU开销大，性能不佳。</li></ul></li></ul><ul><li><b>基于CXL的物理内存池 (Physical Memory Pools)</b>: 这是当前CXL内存分离的主流提议，它使用一个物理上独立的盒子作为共享内存池，与所有服务器分离。<ul><li><b>局限性</b>:</li></ul><ol start="1"><li><b>额外成本</b>: 需要为内存池购置额外的硬件（如电源、主板、CPU或ASIC/FPGA）、占用额外的机架空间，并消耗交换机端口。</li></ol><ol start="2"><li><b>性能损失</b>: 即使使用CXL，访问物理池的内存也比访问本地内存慢3-10倍。</li></ol><ol start="3"><li><b>缺乏近内存计算能力</b>: 物理内存池本身没有CPU或加速器，虽然可以添加，但这会进一步加剧成本问题。</li></ol><ol start="4"><li><b>缺乏灵活性</b>: 本地内存与池化内存的比例在部署后是固定的。如果工作负载的工作集大小超过了本地内存，性能会急剧下降，这迫使部署时可能需要过度配置本地内存，从而违背了内存分离的初衷。</li></ol></li></ul><h2 id="h2-6">论文发现以及论文贡献</h2><p><b>核心发现/提议</b>: 论文的核心提议是构建一种名为逻辑内存池（Logical Memory Pools, LMPs）的新型内存分离架构。其关键思想是，不使用一个独立的物理内存池，而是通过划分每台服务器的部分本地内存来共同组成一个共享内存池。这样，每台服务器的内存被逻辑上划分为“私有”（private）区域和“共享”（shared）区域，所有服务器的“共享”区域共同构成了整个分离内存池。 <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/686b61fd58cb8da5c8933eea.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/686b61fd58cb8da5c8933eea.png" alt=""></a> <b>主要贡献</b>: 相比于物理内存池，逻辑内存池带来了显著的优势，这也是本文的主要贡献：</p><ol start="1"><li><b>更低的成本</b>: LMPs避免了物理池所需的额外硬件、机架空间和交换机端口，因为它们利用了服务器现有的基础设施。</li></ol><ol start="2"><li><b>支持近内存计算 (Near-Memory Computing)</b>: 由于共享内存本身就位于某个服务器上，该服务器强大的CPU、GPU或加速器可以直接对这部分内存进行本地计算，无需额外硬件。这可以通过数据放置、数据迁移或计算迁移三种机制实现。</li></ol><ol start="3"><li><b>更高的灵活性</b>: 每个服务器上私有和共享内存的比例可以根据工作负载的需求动态调整。这使得LMPs能够适应不同应用的需求，避免了物理池固定比例带来的僵化问题。</li></ol><ol start="4"><li><b>更好的性能</b>: 当服务器访问的数据恰好位于其本地的“共享”区域时，访问速度是本地内存的速度，远快于访问远程内存。论文的评估表明，LMPs可以提供比物理池高出4.7倍的带宽。</li></ol><p>基于这些优势，论文呼吁CXL社区应将研究重点从物理内存池转向逻辑内存池。</p><h2 id="h2-7">方法策略</h2><p><b>架构设计</b>:</p><ul><li>在LMP架构中，服务器的内存被划分为两部分：<ul><li><b>私有内存 (Private Memory)</b>: 仅供本地处理器访问，用于存储操作系统、进程控制块、栈和堆等本地状态。</li></ul><ul><li><b>共享区域 (Shared Regions)</b>: 可被全局任何服务器访问，所有服务器的共享区域共同构成了分离内存。</li></ul></li></ul><ul><li>整个系统呈现出一个NUMA（非均匀内存访问）形态，其中内存访问分为延迟极低的本地访问和延迟较高的远程访问。</li></ul><ul><li>为了实现该架构，需要一个服务器端的运行时（runtime）和应用库，用于分配和管理分离内存。运行时还需要执行后台任务，以动态调整共享区域大小和执行数据迁移，从而优化数据局部性。</li></ul><p><b>遇到的困难与解决策略</b>: 论文明确指出了实现逻辑内存池面临的五大挑战及其初步解决思路：</p><ol start="1"><li><b>缓存一致性 (Cache Coherence)</b>: 在多服务器间维护共享内存的缓存一致性难以扩展。<ul><li><b>策略</b>: 不为大部分共享内存提供硬件一致性，而是只提供少量（几GB）的一致性内存用于同步和协调。这可以减轻窥探过滤器的压力。同时，可以利用交换机中的一致性引擎来减少本地访问的开销。</li></ul></li></ol><ol start="2"><li><b>调整共享区域大小 (Sizing the shared regions)</b>: 如何为每个服务器的共享区域分配合理的大小是一个关键问题。分配过大会影响本地工作负载，过小则无法满足应用需求。<ul><li><b>策略</b>: 将其构建为一个全局优化问题，周期性地求解，目标是在优先满足高价值应用的同时最大化本地访问次数。</li></ul></li></ol><ol start="3"><li><b>局部性平衡 (Locality balancing)</b>: 类似于NUMA系统，LMPs需要通过数据迁移来最大化本地访问。由于LMPs中本地和远程访问的性能差距更大，平衡显得尤为重要。<ul><li><b>策略</b>: 使用性能计数器来识别访问缓慢的远程数据，并利用访问位来识别热点数据以决定迁移内容。</li></ul></li></ol><ol start="4"><li><b>地址翻译 (Address translation)</b>: 需要一种高效的机制将逻辑地址映射到其物理位置（即在哪台服务器上），同时支持数据迁移而不使地址失效。<ul><li><b>策略</b>: 提出一种两步翻译方案：第一步进行粗粒度的映射，将逻辑地址映射到目标服务器；第二步在目标服务器内部进行细粒度的本地解析。</li></ul></li></ol><ol start="5"><li><b>故障域 (Failure domains)</b>: 服务器宕机会导致部分共享内存池的丢失。<ul><li><b>策略</b>: 可以借鉴为物理池提出的解决方案，如通过复制或纠删码来掩盖故障，或者通过异常向应用程序报告故障。</li></ul></li></ol><h2 id="h2-8">实验设置与实验结果</h2><ul><li><b>实验平台</b>:<ul><li>实验并非在真实的CXL硬件上进行，因为CXL 3.0 Fabric尚未上市。</li></ul><ul><li>实验平台是一个双路服务器（Intel Xeon Gold 5120 CPU），使用其NUMA架构来模拟CXL Fabric。两个CPU Socket之间的UPI链路被用作模拟的远程连接。</li></ul><ul><li>为了更真实地模拟CXL的预期性能，作者通过降低远程CPU的uncore频率来人为减慢一个UPI链路（称为Link1），并将其与未减慢的基线链路（Link0）进行比较。Link1被认为是更接近未来真实CXL性能的近似值。</li></ul></li></ul><ul><li><b>实验设置与对比公平性</b>:<ul><li><b>对比对象</b>: 实验对比了三种内存池配置：<code>Logical</code>（论文提出的LMP方案）、<code>Physical cache</code>（带本地缓存的物理池）、<code>Physical no-cache</code>（不带本地缓存的物理池）。</li></ul><ul><li><b>对比指标</b>: 主要的性能指标是聚合带宽（Aggregation BW (GB/s)）。延迟（Latency）也被讨论。</li></ul><ul><li><b>公平性</b>: 为了公平对比，所有配置的总内存预算被严格控制为相同的值（96GB）。在物理池配置中，64GB分配给池，每个服务器保留8GB本地内存。在逻辑池配置中，96GB被均匀分配给4个服务器，每个服务器24GB。这种设置使得对比的不是内存总量，而是不同架构对内存的利用效率和性能，因此是公平且有意义的。</li></ul></li></ul><ul><li><b>实验结果与效果</b>:</li></ul><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/686b623358cb8da5c8933f06.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/686b623358cb8da5c8933f06.png" alt=""></a> <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/686b625158cb8da5c8933f0f.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/686b625158cb8da5c8933f0f.png" alt=""></a></p><ul><li><b>性能优势（解决问题效果好）</b>:</li></ul><ul><li>当数据可以完全放入一个LMP服务器的本地内存时（8GB和24GB向量），LMP的带宽最高是<code>Physical no-cache</code>的4.7倍，是<code>Physical cache</code>的3.4倍。这是因为LMP可以直接进行高速的本地内存访问。</li></ul><ul><li>即使数据量超过单个服务器的本地内存（64GB向量），LMP仍然有性能优势，因为它能本地访问一部分数据（3/8），在Link1上带宽高出<code>Physical cache</code> 42%。</li></ul><ul><li><b>合理性分析（取得这样效果是合理的）</b>:</li></ul><ul><li>结果的合理性在于，随着远程链路（模拟CXL）变得越慢，LMP中不受影响的本地访问性能所带来的优势就越明显。</li></ul><ul><li><b>优势展示（比相关工作好、消融实验）</b>:</li></ul><ul><li>对比<code>Physical cache</code>和<code>Physical no-cache</code>可以看作是对物理池方案的一种消融分析，表明即使物理池使用了缓存优化，LMP依然更优。</li></ul><ul><li>在96GB向量的实验中，物理池由于池容量（64GB）不足而无法运行该工作负载。而LMP则可以通过动态调整，让每个服务器贡献全部内存，从而成功容纳并运行该任务。这极好地展示了LMP在灵活性上的绝对优势，解决了物理池无法解决的问题。</li></ul><h2 id="h2-9">前提假设与局限性</h2><p><b>前提假设</b>:</p><ol start="1"><li><b>技术可行性</b>: 论文的一个核心假设是，未来的CXL或类似技术将支持共享的Fabric-Attached Memory (Shared FAMs)，并且允许一台服务器访问另一台服务器主板上的物理内存。这是实现LMP的技术基础。</li></ol><ol start="2"><li><b>应用容忍度</b>: 假设应用和系统可以接受大部分共享内存不提供硬件缓存一致性的设定，仅依赖少量一致性内存进行协调。</li></ol><ol start="3"><li><b>近内存计算的价值</b>: 假设通过数据放置、迁移和计算迁移实现的近内存计算能带来显著的性能收益，从而证明LMP架构的优越性。</li></ol><p><b>局限性</b>:</p><ul><li>失去了原本物理池灵活拓展容量的能力。</li></ul><h2 id="h2-10">物理池和逻辑池的对比</h2><table><tr><th>特性 (Feature)</th><th>物理内存池 (Physical Memory Pool)</th><th>逻辑内存池 (Logical Memory Pool)</th></tr><tr><td style="text-align:left">                <b>基本理念</b></td><td style="text-align:left">                一个与所有服务器物理上分离的、独立的共享内存硬件盒子。</td><td style="text-align:left">                通过划分每台服务器的部分本地内存，共同组成一个逻辑上的共享池。</td></tr><tr><td style="text-align:left">                <b>主要优点</b></td><td style="text-align:left">                允许内存和计算资源进行更独立的扩展。</td><td style="text-align:left">                成本更低、支持近内存计算、且在调整内存比例上更灵活。</td></tr><tr><td style="text-align:left">                <b>主要缺点</b></td><td style="text-align:left">                部署成本高、有性能损失、缺乏近内存计算能力、内存比例固定僵化。</td><td style="text-align:left">                需要解决缓存一致性、区域大小划分、局部性平衡、地址翻译和故障域等分布式系统挑战。</td></tr><tr><td style="text-align:left">                <b>部署成本</b></td><td style="text-align:left">                需要额外的硬件（电源、主板、CPU/ASIC）、机架空间和交换机端口。</td><td style="text-align:left">                利用服务器现有的机架基础设施，不需要额外的机架空间或交换机端口。</td></tr><tr><td style="text-align:left">                <b>性能</b></td><td style="text-align:left">                所有对池的访问都是远程访问，延迟比本地内存高3-5倍，带宽低4-10倍。</td><td style="text-align:left">                当访问的数据位于本地服务器的共享区时，能以本地内存速度访问。实验中带宽最高可提升4.7倍。</td></tr><tr><td style="text-align:left">                <b>灵活性</b></td><td style="text-align:left">                本地与池化内存的比例在部署后是固定的，难以调整。</td><td style="text-align:left">                服务器可以动态调整其私有和共享内存的比例，以适应工作负载需求。</td></tr><tr><td style="text-align:left">                <b>近内存计算</b></td><td style="text-align:left">                不可行，或需要为内存池额外配置昂贵的处理硬件。</td><td style="text-align:left">                可利用服务器本身强大的CPU/GPU直接对本地共享区的数据进行计算，无需额外硬件。</td></tr><tr><td style="text-align:left">                <b>架构挑战</b></td><td style="text-align:left">                主要挑战在于如何缓解远程访问带来的性能损失，以及可能出现的“Incast”拥塞问题。</td><td style="text-align:left">                需要设计复杂的运行时系统来管理缓存一致性、动态调整区域大小、进行数据迁移以平衡局部性、和高效的地址翻译。</td></tr><tr><td style="text-align:left">                <b>共同点</b></td><td style="text-align:left">                两者都通过CXL Fabric连接，都为服务器提供一个全局的地址空间，并使用CPU的加载/存储指令进行访问。</td><td style="text-align:left">                两者都通过CXL Fabric连接，都为服务器提供一个全局的地址空间，并使用CPU的加载/存储指令进行访问。</td></tr></table></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../内存池化/Pond" >内存池化</a><ul><li><a href="../../内存池化/Pond" >Pond</a></li></ul><ul><li><a href="../../内存池化/Direct_CXL" >Direct_CXL</a></li></ul><ul><li><a href="../../内存池化/Against_CXL_Memory_Pooling" >Against_CXL_Memory_Pooling</a></li></ul><ul><li><a href="../../内存池化/Logical Memory Pools:  Flexible and Local Disaggregated Memory" >Logical Memory Pools:  Flexible and Local Disaggregated Memory</a></li></ul><ul><li><a href="../../内存池化/STARNUMA: Mitigating NUMA Challenges with Memory Pooling" >STARNUMA: Mitigating NUMA Challenges with Memory Pooling</a></li></ul><ul><li><a href="../../内存池化/Performance Evaluation on CXL-enabled Hybrid  Memory Pool" >Performance Evaluation on CXL-enabled Hybrid  Memory Pool</a></li></ul><ul><li><a href="../../内存池化/Memory Sharing with CXL: Hardware and Software Design Approaches" >Memory Sharing with CXL: Hardware and Software Design Approaches</a></li></ul></li></ul><ul><li><a href="../../内存分级/TPP" >内存分级</a><ul><li><a href="../../内存分级/TPP" >TPP</a></li></ul><ul><li><a href="../../内存分级/NeoMem" >NeoMem</a></li></ul></li></ul><ul><li><a href="../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices" >带宽与延迟</a><ul><li><a href="../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices" >Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices</a></li></ul><ul><li><a href="../../带宽与延迟/Systematic CXL Memory Characterization and  Performance Analysis at Scale" >Systematic CXL Memory Characterization and  Performance Analysis at Scale</a></li></ul></li></ul><ul><li><a href="../../CXL-SSD/Hello_Bytes" >CXL-SSD</a><ul><li><a href="../../CXL-SSD/Hello_Bytes" >Hello_Bytes</a></li></ul><ul><li><a href="../../CXL-SSD/Cache_in_Hand" >Cache_in_Hand</a></li></ul></li></ul><ul><li><a href="../../simulation/CXL-DMsim" >simulation</a><ul><li><a href="../../simulation/CXL-DMsim" >CXL-DMsim</a></li></ul></li></ul><ul><li><a href="../../CXL探索/Enhanced_Memory_Functions" >CXL探索</a><ul><li><a href="../../CXL探索/Enhanced_Memory_Functions" >Enhanced_Memory_Functions</a></li></ul></li></ul><ul><li><a href="../../内存拓展/Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller" >内存拓展</a><ul><li><a href="../../内存拓展/Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller" >Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller</a></li></ul><ul><li><a href="../../内存拓展/Accelerating_Performance_of_GPU-based_Workloads_Using_CXL" >Accelerating_Performance_of_GPU-based_Workloads_Using_CXL</a></li></ul></li></ul><ul><li><a href="../../Prefetch/Polaris: Enhancing CXL-based Memory Expanders with Memory-side Prefetching" >Prefetch</a><ul><li><a href="../../Prefetch/Polaris: Enhancing CXL-based Memory Expanders with Memory-side Prefetching" >Polaris: Enhancing CXL-based Memory Expanders with Memory-side Prefetching</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../内存池化/Against_CXL_Memory_Pooling","../../内存池化/STARNUMA: Mitigating NUMA Challenges with Memory Pooling","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>