<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/IcarusSong/cxl-papers.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">Direct Access, High-Performance Memory Disaggregation with DIRECTCXL</a><ul><li><a href="#h2-1">作者以及出版物</a><ul><li><a href="#h3-2">作者</a></li></ul><ul><li><a href="#h3-3">出版物</a></li></ul></li></ul><ul><li><a href="#h2-4">1. 内存解耦背景</a></li></ul><ul><li><a href="#h2-5">2. 现有方法：基于页面和基于对象的内存解耦</a><ul><li><a href="#h3-6">2.1 基于页面的方法</a></li></ul><ul><li><a href="#h3-7">2.2 基于对象的方法</a></li></ul><ul><li><a href="#h3-8">2.3 共性问题：对 RDMA 的依赖</a></li></ul></li></ul><ul><li><a href="#h2-9">3. RDMA 的局限</a></li></ul><ul><li><a href="#h2-10">4. 本文提出的 Direct CXL 方案</a><ul><li><a href="#h3-11">4.1 连接方式</a></li></ul><ul><li><a href="#h3-12">4.2 软件运行时</a></li></ul><ul><li><a href="#h3-13">4.3 原型实现</a></li></ul></li></ul><ul><li><a href="#h2-14">5. Direct CXL 与 RDMA 的对比（第四部分评估）</a></li></ul><ul><li><a href="#h2-15">总结</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">Direct Access, High-Performance Memory Disaggregation with DIRECTCXL</h1><h2 id="h2-1">作者以及出版物</h2><h3 id="h3-2">作者</h3><p>Donghyun Gouk, Sangwon Lee, Miryeong Kwon, Myoungsoo Jung，<b>KAIST</b></p><h3 id="h3-3">出版物</h3><p>ACT24</p><hr><h2 id="h2-4"><ol start="1"><li>内存解耦背景</li></ol></h2><p>随着数据中心和大规模计算任务对内存容量及利用率要求的不断提高，<b>内存解耦（Memory Disaggregation）</b> 作为一种新型架构，被提出以实现内存资源池化、弹性扩展和高效共享。通过将内存资源从计算节点中分离出来，可以在多个主机之间灵活调度内存，从而提高整体系统的资源利用率。</p><hr><h2 id="h2-5"><ol start="2"><li>现有方法：基于页面和基于对象的内存解耦</li></ol></h2><h3 id="h3-6">2.1 基于页面的方法</h3><ul><li><b>原理：</b><p>该方法依赖虚拟内存技术，当主机发生 page fault 时，将本地缓存的页数据交换到远程内存节点。</p></li></ul><ul><li><b>优点与问题：</b><p>具有透明性，不需应用修改，但需要频繁处理页故障、上下文切换以及数据复制开销，容易引起 I/O 放大效应。</p></li></ul><h3 id="h3-7">2.2 基于对象的方法</h3><ul><li><b>原理：</b><p>以 key-value store 的形式直接管理远程内存，应用程序需要修改源代码，以适配新的数据访问接口。</p></li></ul><ul><li><b>优点与问题：</b><p>可以规避页级调度的开销，但由于核心设计依赖数据的封装和额外运算（如哈希处理），造成额外的计算开销和延迟，且需要较大改动应用程序代码。</p></li></ul><h3 id="h3-8">2.3 共性问题：对 RDMA 的依赖</h3><ul><li>不论是基于页面还是基于对象的内存解耦方法，目前都采用了 <b>RDMA（Remote Direct Memory Access）</b> 技术来传输数据。</li></ul><ul><li><b>问题在于：</b><p>RDMA 在实际操作时需要经过两次 DMA 操作、协议转换以及软件栈的介入，导致数据复制和网络管理开销较大，从而使得远程内存访问延迟比本地 DRAM 延迟高出多个数量级。</p></li></ul><hr><h2 id="h2-9"><ol start="3"><li>RDMA 的局限</li></ol></h2><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67fcf92988c538a9b5d0dbec.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67fcf92988c538a9b5d0dbec.png" alt=""></a></p><p>当前大多数内存解耦方案都依赖于 RDMA 技术，但其在实际应用中存在明显的延迟和数据传输开销问题。图中详细展示了 RDMA 数据传输的关键步骤，揭示了其主要局限性，具体包括：</p><ol start="1"><li><b>内存区域注册与数据拷贝开销</b><ul><li><b>注册阶段：</b><p>主机和远程内存节点在开始传输前，需要将各自要使用的数据区域注册到 RDMA 网卡（RNIC），并在网卡内部建立一个内存转换表（MTT）。这一步确保了虚拟地址与物理地址的映射，但同时也增加了配置和管理开销。</p></li></ul><ul><li><b>数据拷贝：</b><p>为确保数据直接由 RNIC 进行 DMA 传输，必须先将应用数据复制到注册的内存缓冲区（pinned memory），传输完成后在接收端还需要再次拷贝数据到应用程序的缓冲区。这一系列拷贝操作不仅增加了整体延迟，而且在高负载和小数据传输时尤为明显。</p></li></ul></li></ol><ol start="2"><li><b>协议转换和网络传输延迟</b><ul><li>RDMA 通过网络直接进行数据传输（例如 InfiniBand），图中显示当主机发起一个含有目标地址、数据长度等参数的请求时，RNIC将利用内部 DMA 机制将数据直接写入远程内存。</li></ul><ul><li>尽管 RDMA 能够绕过传统 TCP/IP 协议栈，但仍需经过两次 DMA 操作，并处理相关协议转换，这使得单次访问的硬件延迟（例如图 6 中的 2700+ cycles）明显高于直接访问本地 DRAM。</li></ul></li></ol><ol start="3"><li><b>整体延迟分布和尾延迟问题</b><ul><li>如图所示，RDMA 的完整路径不仅包含上面提到的硬件延迟，还叠加了软件栈（如 libibverbs）的额外开销。</li></ul><ul><li>实际测量发现，在应用级别统计中 RDMA 的延迟可能达到 4000+ cycles，而在内存层级视角下，仅硬件传输部分的延迟大约 2000 cycles。这种多级叠加带来的延迟波动（tail latency）使得 RDMA 在延迟敏感型应用中的表现较差。</li></ul></li></ol><ul><li><b>总结：</b><p>RDMA 的整体开销使得基于其的内存解耦解决方案在延迟上远不能与直接访问本地 DRAM 相比。</p></li></ul><hr><h2 id="h2-10"><ol start="4"><li>本文提出的 Direct CXL 方案</li></ol></h2><p>为了解决上述 RDMA 高延迟以及复杂软件栈带来的问题，文章提出了 <b>Direct CXL</b>，其核心思想是利用 CXL（Compute Express Link）标准中的内存协议（CXL.mem），实现主机与远程内存之间的直接、低延迟通信。其设计主要涵盖如下几个方面：</p><h3 id="h3-11">4.1 连接方式</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67fcfa9788c538a9b5d0dce4.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67fcfa9788c538a9b5d0dce4.png" alt=""></a></p><ul><li><b>硬件设计：</b><ul><li>直接将远程内存节点作为一个纯被动模块，通过 PCIe 总线与主机的 CXL root port 相连。</li></ul><ul><li>在远程设备侧使用多个 DRAM 控制器管理 DRAM 模块，CXL 控制器负责将 PCIe 传输的数据转换为 DRAM 请求。</li></ul><ul><li>通过 CXL switch 建立虚拟层级，实现主机与多个远程内存节点的灵活组合。</li></ul><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67fcfaad88c538a9b5d0dcf1.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67fcfaad88c538a9b5d0dcf1.png" alt=""></a></p></li></ul><h3 id="h3-12">4.2 软件运行时</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67fcfac788c538a9b5d0dd0b.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67fcfac788c538a9b5d0dd0b.png" alt=""></a></p><ul><li><b>设计思路：</b><ul><li>提供一个简洁的 CXL 软件运行时，将远程内存映射为 <b>cxl-namespace</b>，类似于内存映射文件（mmap）。</li></ul><ul><li>该运行时通过 ioctl 接口管理 namespace 的分配和映射，无需应用级别修改代码，直接支持 load/store 指令访问远程内存。</li></ul></li></ul><h3 id="h3-13">4.3 原型实现</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67fcfaf388c538a9b5d0dd23.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67fcfaf388c538a9b5d0dd23.png" alt=""></a></p><ul><li><b>原型构建：</b><ul><li>系统基于 FPGA 实现的 CXL 内存 add-in 卡和基于 RISC-V 的主机处理器搭建；</li></ul><ul><li>利用 PCIe backplane 和自研 CXL switch，将多台主机与多块 CXL 设备连接成一个内存池系统；</li></ul><ul><li>软件上通过 Linux 5.13 和自研驱动实现 CXL 枚举、内存映射及数据传输功能。</li></ul></li></ul><hr><h2 id="h2-14"><ol start="5"><li>Direct CXL 与 RDMA 的对比（第四部分评估）</li></ol></h2><p><b>评估部分</b>详细通过微基准测试和真实工作负载测试对 Direct CXL 和基于 RDMA 的内存解耦方案进行了对比分析，主要对比内容如下：</p><ul><li><b>延迟方面：</b><ul><li><b>硬件路径延迟：</b></li></ul><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67fcfb2b88c538a9b5d0dd48.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67fcfb2b88c538a9b5d0dd48.png" alt=""></a></p><p>Direct CXL 在单次 64B 数据读取测试中，延迟仅为 328 cycles，而 RDMA 在相同测试条件下延迟约 2705 cycles，从硬件实现来看，Direct CXL 快了大约 8.3 倍。</p><ul><li><b>实际应用延迟：</b></li></ul><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67fcfb5f88c538a9b5d0dd5d.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67fcfb5f88c538a9b5d0dd5d.png" alt=""></a></p><p>当考虑软件栈和数据复制开销时，RDMA 的延迟明显上升，达到 4000+ cycles，而 Direct CXL 则因省去了大量软件干预和数据复制，延迟更稳定、接近本地 DRAM 的访问特性。</p><ul><li><b>内存层级分析（图 8）：</b></li></ul><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67fcfb9288c538a9b5d0dd72.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67fcfb9288c538a9b5d0dd72.png" alt=""></a></p><p>以内存层级视角看，RDMA 的延迟在 2000+ cycles，而 Direct CXL 则为 328 cycles，显示出其在延迟分布和 tail latency 方面的优势。</p></li></ul><ul><li><b>可扩展性及并发性：</b><ul><li><b>RDMA：</b> 软件库、数据复制和网络处理瓶颈明显，系统在高并发访问下性能急剧下降。</li></ul><ul><li><b>Direct CXL：</b> 能够利用直接 load/store 指令和高效的内存映射机制，在多核心并发访问下保持较低延迟和线性增长的带宽，极大地提高了整体可扩展性。</li></ul></li></ul><ul><li><b>真实工作负载表现：</b></li></ul><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67fcfbd488c538a9b5d0dd9c.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67fcfbd488c538a9b5d0dd9c.png" alt=""></a></p><ul><li>在 DLRM、MemDB 和图计算等多种真实工作负载测试中，Direct CXL 相对于基于页交换的 Swap 模型和基于对象的 KVS 模型，分别提升了 3 倍和 2.2 倍的性能，说明其在实际应用场景中具有更高的优势和适应性。</li></ul><hr><h2 id="h2-15">总结</h2><p>文章首先讨论了内存解耦的重要背景及当前常用的两种基于页面与基于对象的方法，这两类方法均依赖于 RDMA 技术，而 RDMA 本身因涉及多重数据复制和复杂协议转换而导致较高延迟。接着，文章提出 Direct CXL 方案，通过直接将远程内存映射到主机系统中，并提供轻量级的软件运行时，实现了直接访问远程内存的目标。最后，通过微基准测试和实际工作负载测试，文章详细证明了 Direct CXL 在延迟、带宽及系统可扩展性等方面显著优于基于 RDMA 的内存解耦方案。</p></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../内存池化/Pond" >内存池化</a><ul><li><a href="../../内存池化/Pond" >Pond</a></li></ul><ul><li><a href="../../内存池化/Direct_CXL" >Direct_CXL</a></li></ul><ul><li><a href="../../内存池化/Against_CXL_Memory_Pooling" >Against_CXL_Memory_Pooling</a></li></ul></li></ul><ul><li><a href="../../内存分级/TPP" >内存分级</a><ul><li><a href="../../内存分级/TPP" >TPP</a></li></ul><ul><li><a href="../../内存分级/NeoMem" >NeoMem</a></li></ul></li></ul><ul><li><a href="../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices" >带宽与延迟</a><ul><li><a href="../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices" >Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices</a></li></ul></li></ul><ul><li><a href="../../CXL-SSD/Hello_Bytes" >CXL-SSD</a><ul><li><a href="../../CXL-SSD/Hello_Bytes" >Hello_Bytes</a></li></ul><ul><li><a href="../../CXL-SSD/Cache_in_Hand" >Cache_in_Hand</a></li></ul></li></ul><ul><li><a href="../../simulation/CXL-DMsim" >simulation</a><ul><li><a href="../../simulation/CXL-DMsim" >CXL-DMsim</a></li></ul></li></ul><ul><li><a href="../../CXL探索/Enhanced_Memory_Functions" >CXL探索</a><ul><li><a href="../../CXL探索/Enhanced_Memory_Functions" >Enhanced_Memory_Functions</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../内存池化/Pond","../../内存池化/Against_CXL_Memory_Pooling","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>