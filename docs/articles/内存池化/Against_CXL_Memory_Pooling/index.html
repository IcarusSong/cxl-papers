<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/IcarusSong/cxl-papers.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">A Case Against CXL Memory Pooling</a><ul><li><a href="#h2-1">作者与出版物</a><ul><li><a href="#h3-2">作者</a></li></ul><ul><li><a href="#h3-3">出版物</a></li></ul></li></ul><ul><li><a href="#h2-4">背景</a></li></ul><ul><li><a href="#h2-5">本文观察</a></li></ul><ul><li><a href="#h2-6">背景知识</a><ul><li><a href="#h3-7">CXL延迟组成</a></li></ul><ul><li><a href="#h3-8">Pond回顾</a></li></ul></li></ul><ul><li><a href="#h2-9">对于文本的不赞同</a></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">A Case Against CXL Memory Pooling</h1><h2 id="h2-1">作者与出版物</h2><h3 id="h3-2">作者</h3><ul><li>Philip Levis Google plevis@google.com</li></ul><ul><li>Kun Lin  Google linkun@google.com</li></ul><ul><li>Amy Tai  Google amytai@google.com</li></ul><h3 id="h3-3">出版物</h3><p>HotNets ’23</p><h2 id="h2-4">背景</h2><p>在数据中心和云服务器中，计算资源和内存资源紧耦合，同时内存占据高昂的服务器成本（Azure为50%）。如果服务器内存不足，可能会出现空闲核心但没有可用内存的情况（核心闲置）；如果内存过多，则可能出现空闲内存而核心不使用的情况（内存闲置。鉴于此种原因，学术界提出了内存解耦/内存池化的方法，即服务器拥有自己的本地 RAM，足以满足平均或预期使用量。如果服务器需要更多内存或存在闲置核心，它可以从多个服务器共享的池中进行分配。</p><p>CXL协议有望为远程内存（内存池）提供低延迟、缓存一致性的访问，已经被视为一个内存池方案的最佳标准。</p><h2 id="h2-5">本文观察</h2><p>虽然CXL有着种种优点，但是本文认为CXL内存池化面临三个严峻的问题，在层层问题的叠加之下，CXL内存池化成为了奢想。 三个问题如下：</p><ul><li>成本：CXL内存池化所需的机架以及新的CXL内存成本可能超过给服务器增加DRAM的成本</li></ul><ul><li>软件复杂性：当前真实CXL硬件的延迟比理想延迟要高，进行内存池化还需要CXL交换机，这必然也会带来延迟的增加。因此，在高延迟的情况下，想要软件获得良好的性能，需要重写软件来显示管理CXL内存(类似于cuda cpoy)，并将块复制到本地DRAM中，这种显示、条件性和普遍性的内存管理增加了软件的复杂性。</li></ul><ul><li>实用性有限：现代服务器相对于大多数虚拟机来说已经非常大了 ；即使是简单的虚拟机打包算法也很少会留下搁浅内存，这从根本上削弱了内存池化的主要动机。</li></ul><p>作者认为只要上述问题依然存在，利用CXL内存进行CXL内存池化就是一个奢想。</p><h2 id="h2-6">背景知识</h2><h3 id="h3-7">CXL延迟组成</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/685dfa6858cb8da5c874c73c.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/685dfa6858cb8da5c874c73c.png" alt=""></a> 执行一条load指令访问CXL设备，延迟如图所示</p><ul><li>阶段一：在服务器内部的发起 (左上部分)<ol start="1"><li>Instruction Stream &amp; movz...: 这一切始于 CPU 执行的一条指令，例如 movz，它需要从内存中加载数据。</li></ol><ol start="2"><li>Cache and memory lookups: CPU 首先会检查自己的高速缓存（L1, L2, L3 cache）里有没有需要的数据</li></ol><ol start="3"><li>Interconnect: 检查未命中后，由于这是一个双插槽（dual-socket）服务器，请求可能需要通过CPU之间的内部互连总线（Interconnect）发送到另一个CPU，因为CXL设备可能连接在另一个CPU上。这个跨CPU的通信本身就会增加延迟</li></ol><ol start="4"><li>Cache and memory lookups: 在另一个CPU上，再次检查其本地缓存和直连的内存（DRAM）</li></ol><ol start="5"><li>Request generation: 当在所有本地缓存和本地内存中都找不到数据时，系统确认该数据位于远端的CXL内存池中，于是生成一个正式的CXL请求</li></ol></li></ul><ul><li>阶段二：请求的打包与远征 (左下部分 - CXL Overhead)<ol start="1"><li>TL processing (事务层处理): 将内存读写请求转换成CXL事务</li></ol><ol start="2"><li>CXL flit packing (CXL流控单元打包): 将事务数据切割并打包成称为“flit”的标准大小数据块</li></ol><ol start="3"><li>VCS, vPPB, CRC, Credits, Replay: 这是协议的链路层，负责虚拟信道管理、添加CRC校验码以确保数据准确性、流量控制（Credits）以及错误重传（Replay）等功能</li></ol><ol start="4"><li>Framing, Encoding (成帧与编码): 将数据打包成帧，并进行物理层编码，使其适合在电缆上传输</li></ol><ol start="5"><li>Transmission: 最后，通过物理接口将编码后的信号发送出去</li></ol></li></ul><ul><li>阶段三：跨越鸿沟 (中间部分)<ol start="1"><li>Cable propagation delay (线缆传播延迟): 信号在物理电缆中传输需要时间，这是由物理距离决定的、不可避免的延迟</li></ol></li></ul><ul><li>阶段四：在内存池的接收与拆包 (右下部分 - CXL Overhead)<ol start="1"><li>Reception, Decoding, Deframing (接收、解码、解帧): 接收物理信号，将其解码并还原成数据帧</li></ol><ol start="2"><li>VCS, vPPB...: 再次经过链路层处理</li></ol><ol start="3"><li>CXL flit unpacking: 将flit重新组装成CXL事务</li></ol><ol start="4"><li>TL processing: 将CXL事务还原成内存控制器能理解的读写请求</li></ol></li></ul><ul><li>阶段五：在内存池内部的寻址与访问 (右上部分)<ol start="1"><li>CXL switch (CXL交换机): 因为内存池可能为多台服务器服务，所以内部需要一个交换机来路由请求。这个交换过程会引入额外的延迟</li></ol><ol start="2"><li>Translate to MMU (转换为MMU地址): 内存池的控制器将请求的地址转换为其内部DRAM芯片上的物理地址</li></ol><ol start="3"><li>DRAM access (DRAM访问): 最后，从DRAM颗粒中真正读取到所需的数据。为了最大化带宽，读取操作通常会跨多个DDR插槽进行</li></ol></li></ul><ul><li>阶段六：数据的返回之路<ul><li>图的说明中提到：“响应会经过相同的路径” 。这意味着，读取到的数据需要重新经历一次完整的打包、物理传输、拆包的过程，才能最终返回到发起请求的CPU。因此，总延迟是这一整个来回旅程的耗时总和</li></ul></li></ul><h3 id="h3-8">Pond回顾</h3><ul><li><b>问题</b>: 云服务商的服务器上存在大量“搁浅内存”（Stranded Memory），即因为 CPU 核心已经分配完，导致剩余的内存无法再分配给新的虚拟机，造成浪费</li></ul><ul><li><b>解决方案</b>: 不要给每台服务器配满内存，而是将一部分（例如 25%）内存抽出来，放到一个由多台服务器共享的 CXL 内存池里</li></ul><ul><li><b>效果</b>: 由于不是所有服务器都会同时达到内存使用高峰，通过“统计复用”（即共享），可以用更少的总内存来满足所有服务器的需求。Pond 的研究声称，这种方法可以节省 7-9% 的总内存，同时对大部分应用性能影响很小</li></ul><h2 id="h2-9">对于文本的不赞同</h2><ul><li>成本：随着CXL工艺的成熟，成本必然会下降，CXL池化的收益将会远超DRAM的浪费。</li></ul><ul><li>软件复杂性：作者没有考虑到os kernel管理页面的情况，认为<b>显式搬运</b>才有好性能，事实是cuda都支持了隐式内存管理，更不用谈cxl这种统一内存的形式。</li></ul><ul><li>实用性有限：本文的数据来自于2019年，显然没有考虑到大模型时代，如果要在服务器上进行推理，如果每台服务器都配备近T级别的内存，但是峰值利用率又不高，这显然会造成内存搁置。</li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../内存池化/Pond" >内存池化</a><ul><li><a href="../../内存池化/Pond" >Pond</a></li></ul><ul><li><a href="../../内存池化/Direct_CXL" >Direct_CXL</a></li></ul><ul><li><a href="../../内存池化/Against_CXL_Memory_Pooling" >Against_CXL_Memory_Pooling</a></li></ul><ul><li><a href="../../内存池化/Logical Memory Pools:  Flexible and Local Disaggregated Memory" >Logical Memory Pools:  Flexible and Local Disaggregated Memory</a></li></ul><ul><li><a href="../../内存池化/STARNUMA: Mitigating NUMA Challenges with Memory Pooling" >STARNUMA: Mitigating NUMA Challenges with Memory Pooling</a></li></ul><ul><li><a href="../../内存池化/Performance Evaluation on CXL-enabled Hybrid  Memory Pool" >Performance Evaluation on CXL-enabled Hybrid  Memory Pool</a></li></ul><ul><li><a href="../../内存池化/Memory Sharing with CXL: Hardware and Software Design Approaches" >Memory Sharing with CXL: Hardware and Software Design Approaches</a></li></ul></li></ul><ul><li><a href="../../内存分级/TPP" >内存分级</a><ul><li><a href="../../内存分级/TPP" >TPP</a></li></ul><ul><li><a href="../../内存分级/NeoMem" >NeoMem</a></li></ul></li></ul><ul><li><a href="../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices" >带宽与延迟</a><ul><li><a href="../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices" >Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices</a></li></ul><ul><li><a href="../../带宽与延迟/Systematic CXL Memory Characterization and  Performance Analysis at Scale" >Systematic CXL Memory Characterization and  Performance Analysis at Scale</a></li></ul></li></ul><ul><li><a href="../../CXL-SSD/Hello_Bytes" >CXL-SSD</a><ul><li><a href="../../CXL-SSD/Hello_Bytes" >Hello_Bytes</a></li></ul><ul><li><a href="../../CXL-SSD/Cache_in_Hand" >Cache_in_Hand</a></li></ul></li></ul><ul><li><a href="../../simulation/CXL-DMsim" >simulation</a><ul><li><a href="../../simulation/CXL-DMsim" >CXL-DMsim</a></li></ul></li></ul><ul><li><a href="../../CXL探索/Enhanced_Memory_Functions" >CXL探索</a><ul><li><a href="../../CXL探索/Enhanced_Memory_Functions" >Enhanced_Memory_Functions</a></li></ul></li></ul><ul><li><a href="../../内存拓展/Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller" >内存拓展</a><ul><li><a href="../../内存拓展/Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller" >Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller</a></li></ul><ul><li><a href="../../内存拓展/Accelerating_Performance_of_GPU-based_Workloads_Using_CXL" >Accelerating_Performance_of_GPU-based_Workloads_Using_CXL</a></li></ul></li></ul><ul><li><a href="../../Prefetch/Polaris: Enhancing CXL-based Memory Expanders with Memory-side Prefetching" >Prefetch</a><ul><li><a href="../../Prefetch/Polaris: Enhancing CXL-based Memory Expanders with Memory-side Prefetching" >Polaris: Enhancing CXL-based Memory Expanders with Memory-side Prefetching</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../内存池化/Direct_CXL","../../内存池化/Logical Memory Pools:  Flexible and Local Disaggregated Memory","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>