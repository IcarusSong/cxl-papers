<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/IcarusSong/cxl-papers.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">Pond</a><ul><li><a href="#h2-1">Abstract</a></li></ul><ul><li><a href="#h2-2">Introduction</a></li></ul><ul><li><a href="#h2-3">Background</a><ul><li><a href="#h3-4">CXL访存</a></li></ul></li></ul><ul><li><a href="#h2-5">Memmory stranding & workload sensitivity to memory latency</a><ul><li><a href="#h3-6">Azure中的内存搁置</a></li></ul><ul><li><a href="#h3-7">Azure中VM的内存使用情况</a></li></ul><ul><li><a href="#h3-8">工作负载对内存延迟的敏感性</a></li></ul></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">Pond</h1><h2 id="h2-1">Abstract</h2><p>云服务商们即希望硬件能够满足性能要求，同时也要降低成本，其中内存就是影响性能和成本的关键因素。恰好内存池化可以提高DRAM利用率，从而降低成本。但是在云服务器上实现池化是个有挑战性的事。</p><blockquote><p>内存池化是指将大量的内存进行池化，形成一个内存池，CPU在内存池中动态申请内存进行使用。</p></blockquote><p>本文提出了Pond，这是首个既能满足云性能目标又能显著降低DRAM成本的内存池系统。Pond基于CXL实现了对内存池中内存的Load/Store语义访问，同时又提出了两个观察：</p><ul><li>跨8-16个插槽的池化足以实现大部分收益。这使得小规模池设计能够实现低访问延迟。</li></ul><ul><li>通过机器学习模型可以准确预测为虚拟机（VM）分配多少本地内存和池内存，以实现与同NUMA节点内存相近的性能。</li></ul><p>Pond能够将DRAM成本降低7%，同时性能与同NUMA节点VM分配相比仅相差1-5%。</p><h2 id="h2-2">Introduction</h2><p>云服务商为了保证云客户虚拟机(VM)的性能，常常将VM的所有内存都预分配到与其核心相同的NUMA节点上。预分配和静态固定内存还便于使用虚拟化加速器。</p><blockquote><p>内存性能的黄金标准是访问由发出请求的核心所在的同一NUMA节点提供服务，从而实现数十纳秒的延迟。</p></blockquote><p>由于DRAM的可拓展性较差且替代方案不成熟，DRAM已经成为了硬件的主要即成本。比如：</p><ul><li>Azure中，DRAM可占服务器成本的50%</li></ul><ul><li>Meta占机架成本的40%</li></ul><p>由于VM的内存分配策略，导致了核心在分配给VM时，该核心仍有剩余内存不会被租用，这会造成内存搁置。随着更多核心分配给VM，高达25%的DRAM会被搁置。</p><p>现有技术应对搁浅问题仍然具有挑战性，如：</p><ul><li>现有池化技术（RMDA/PCIe），闲置内存可返回到内存池中供其它VM使用，但是由于技术原因，访问延迟过高，并且当VM访问池内存时，若数据未提前加载到本地，需触发页面错误，由虚拟机管理程序（Hypervisor）介入，通过软件从池中动态迁移数据，延迟进一步增加。</li></ul><p>Pond，这是首个在公有云平台上同时实现同NUMA节点内存性能和成本竞争力的系统。Pond结合了硬件（CXL）和系统技术（支持CXL池化）。CXL的延迟还是高于NUMA节点，Pond引入了支持CXL池化的系统技术，显著降低了这种高延迟的影响。</p><p>Pond的可行性基于四项<b>关键洞察</b>：</p><ul><li>8-16个插槽的池大小足以实现足够的DRAM节省。在8-16个插槽的池中，CXL会增加70-90ns的访问延迟，而在机架级池化中会增加超过180ns的延迟。</li></ul><ul><li>43%的工作负载在CXL池内存延迟增加64ns时性能损失不超过5%，但21%的工作负载性能下降超25%。这促使Pond采用小规模CXL池（8-16节点）结合机器学习预测，将延迟敏感型和非敏感型工作负载差异化分配，最终实现7%的DRAM节省且95%以上VM性能损失控制在5%以内。</li></ul><ul><li>约50%的VM访问了不到其租用内存的50%，这意味着存在大量&quot;闲置内存&quot;可被重新利用。Pond将池内存作为零核心虚拟NUMA（zNUMA），zNUMA 将池内存呈现为一个&quot;有内存但无 CPU 核心&quot;的特殊 NUMA 节点，操作系统自然地将活跃内存集中在有CPU的NUMA节点，zNUMA内存保持空闲，避免了传统统一地址空间中潜在的性能干扰。<blockquote><p>传统内存池化方案（如 Kang 等人的研究）采用统一地址空间设计，会导致操作系统无差别地使用本地和池内存，造成性能敏感型应用不可避免地访问高延迟的池内存。</p></blockquote></li></ul><ul><li>Pond可以通过正确预测以下两点，以同NUMA节点性能分配CXL内存：a）VM是否对延迟敏感；b）VM的未访问内存量。<ul><li>对于预测错误的情况，Pond引入了一种新颖的监控系统，检测内存性能不佳并触发缓解措施，将VM迁移到仅使用同NUMA节点内存的配置。</li></ul></li></ul><p><b>贡献</b>：</p><ol start="1"><li>首次公开大型公有云提供商的内存搁置和未访问内存特性分析。</li></ol><ol start="2"><li>首次分析不同CXL内存池大小的有效性和延迟。</li></ol><ol start="3"><li>首个基于CXL的完整内存池系统，适用于云部署且性能优异。</li></ol><ol start="4"><li>数据中心规模的准确延迟和资源管理预测模型。这些模型可实现1-5%的可配置性能降级。</li></ol><ol start="5"><li>广泛的评估验证了Pond的设计，包括zNUMA和预测模型在生产环境中的性能。分析表明，Pond通过跨16个插槽的池可以将DRAM需求减少7%，对应大型云提供商数亿美元的成本节约。</li></ol><h2 id="h2-3">Background</h2><h3 id="h3-4">CXL访存</h3><p>最后一级缓存（LLC）对CXL内存地址的未命中会转换为CXL端口上的请求，其响应会引入缺失的缓存行（图1）。类似地，LLC写回会转换为CXL数据写入。这些操作均不涉及页面错误或DMA。 <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67eceebb0ba3d5a1d7ea10c0.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67eceebb0ba3d5a1d7ea10c0.png" alt=""></a></p><h2 id="h2-5">Memmory stranding &amp; workload sensitivity to memory latency</h2><h3 id="h3-6">Azure中的内存搁置</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67ecf4c90ba3d5a1d7ea1592.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67ecf4c90ba3d5a1d7ea1592.png" alt=""></a> 图2展示了在虚拟机（VM）环境中，随着计划分配的CPU核心百分比增加，搁置内存（未被有效利用的DRAM）的比例呈现上升趋势；中位数数据显示，在75% CPU利用率时搁置内存约为6%，而在85% CPU利用率时超过10%；此外，数据的变异性主要由不同VM混合引起，例如计算密集型VM即使在低CPU利用率下也可能导致高搁置内存，而误差条和异常值进一步表明，在高CPU利用率区间，个别情况下搁置内存比例甚至可达到30%，突显了资源分配不均衡与潜在优化需求。</p><p>Azure目前未实现内存池化。然而，通过分析其VM到服务器的跟踪数据，我们可以估计通过池化可以节省的DRAM量。图3展示了当VM以固定百分比（10%、30%或50%）的池DRAM调度时，池化DRAM的平均减少量。 <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67ecf9700ba3d5a1d7eaf524.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67ecf9700ba3d5a1d7eaf524.png" alt=""></a></p><h3 id="h3-7">Azure中VM的内存使用情况</h3><p>总体而言，我们发现虽然VM内存使用情况因集群而异，但所有集群中都有相当一部分VM存在未访问内存。第50百分位数为50%的未访问内存。</p><p>从这一分析中，我们得出以下关键观察和对Pond的启示：</p><ul><li>VM内存使用情况差异很大。</li></ul><ul><li>在未访问内存最少的集群中，仍有超过50%的VM有超过20%的未访问内存。因此，有大量未访问内存可以无性能损失地解聚到池中。</li></ul><ul><li>挑战在于（1）预测VM可能有多少未访问内存；（2）将VM的访问限制在本地内存中。Pond解决了这两个问题。</li></ul><h3 id="h3-8">工作负载对内存延迟的敏感性</h3><p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/67ecfb1d0ba3d5a1d7eaf5fb.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/67ecfb1d0ba3d5a1d7eaf5fb.png" alt=""></a></p></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../内存池化/Pond" >内存池化</a><ul><li><a href="../../内存池化/Pond" >Pond</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../md-docs/README",".","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>