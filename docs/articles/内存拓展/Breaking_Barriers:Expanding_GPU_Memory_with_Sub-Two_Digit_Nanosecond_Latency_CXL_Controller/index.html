<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/IcarusSong/cxl-papers.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">Breaking Barriers: Expanding GPU Memory with  Sub-Two Digit Nanosecond Latency CXL Controller</a><ul><li><a href="#h2-1">作者与出版物</a><ul><li><a href="#h3-2">作者</a></li></ul><ul><li><a href="#h3-3">出版物</a></li></ul></li></ul><ul><li><a href="#h2-4">文章背景</a><ul><li><a href="#h3-5">相关工作以及局限性</a></li></ul></li></ul><ul><li><a href="#h2-6">论文发现以及论文贡献</a></li></ul><ul><li><a href="#h2-7">方法策略</a><ul><li><a href="#h3-8">实验设置与实验结果</a></li></ul><ul><li><a href="#h3-9">前提假设与局限性</a></li></ul></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">Breaking Barriers: Expanding GPU Memory with  Sub-Two Digit Nanosecond Latency CXL Controller</h1><h2 id="h2-1">作者与出版物</h2><h3 id="h3-2">作者</h3><ul><li><b>Donghyun Gouk</b>：来自 Panmnesia, Inc.</li></ul><ul><li><b>Seungkwan Kang</b>：来自 Computer Architecture and Memory Systems Laboratory, KAIST</li></ul><ul><li><b>Hanyeoreum Bae</b>：来自 Computer Architecture and Memory Systems Laboratory, KAIST</li></ul><ul><li><b>Eojin Ryu</b>：来自 Panmnesia, Inc.</li></ul><ul><li><b>Sangwon Lee</b>：来自 Panmnesia, Inc.</li></ul><ul><li><b>Dongpyung Kim</b>：来自 Panmnesia, Inc.</li></ul><ul><li><b>Junhyeok Jang</b>：来自 Computer Architecture and Memory Systems Laboratory, KAIST</li></ul><ul><li><b>Myoungsoo Jung</b>：来自 Panmnesia, Inc. 和 Computer Architecture and Memory Systems Laboratory, KAIST</li></ul><h3 id="h3-3">出版物</h3><p>HOTSTORAGE ’24, July 8–9, 2024, Santa Clara, CA, USA</p><h2 id="h2-4">文章背景</h2><p>该研究的背景是，随着大型深度学习模型（如大语言模型LLM）的兴起，这些模型的内存需求（包括参数、训练元数据、梯度等）已经远远超出了当前高端GPU（如图形处理器）的内存容量。例如，一个拥有1000亿参数的模型就需要远超当前GPU 80GB上限的内存。这导致GPU需要频繁地与主机内存和存储进行数据交换，从而产生显著的性能开销，并增加了编程的复杂性，限制了GPU的应用。因此，研究旨在提出一种高效的GPU内存扩展技术以解决这一挑战。</p><h3 id="h3-5">相关工作以及局限性</h3><p>现有的GPU内存扩展或数据管理方案及其局限性主要包括：</p><ul><li><b>GPU直接存储 (GPUDirect Storage)</b>: 该技术允许GPU直接访问SSD（固态硬盘），利用其巨大的存储容量。<ul><li><b>局限性</b>: GPUDirect因为其复杂性而很少被使用。它将SSD视为块设备，需要开发者手动管理文件系统、处理内存与块访问的I/O粒度差异，并手动处理数据传输（如 <code>cuFileWrite</code>），这使得编程模型变得复杂。</li></ul></li></ul><ul><li><b>统一虚拟内存 (Unified Virtual Memory, UVM)</b>: UVM提供了一个CPU和GPU共享的虚拟内存空间，能够按需自动分配和迁移数据页。<ul><li><b>局限性</b>: 当GPU访问的数据不在本地内存时，会触发页面错误（page fault），需要主机端的运行时软件介入处理。这个过程会引入巨大的延迟，导致性能瓶颈，尤其是在随机访问模式下，会因数据迁移粒度（页）远大于实际所需（缓存行）而加剧问题。</li></ul></li></ul><ul><li><b>现有CXL内存扩展器原型</b>: 许多行业厂商（如三星、美光、SK海力士）已经开发了CXL内存扩展器的原型。基于三星和Meta的报告，这些原型的端到端往返延迟约为250纳秒。<ul><li><b>局限性</b>: 尽管CXL技术允许异步访问，并支持多种存储介质，但现有原型的延迟较高。此外，当前GPU本身缺乏原生的CXL逻辑和子系统来支持将CXL设备作为内存扩展。</li></ul></li></ul><h2 id="h2-6">论文发现以及论文贡献</h2><p><b>论文发现</b>: 论文的核心发现是，通过在硬件RTL（寄存器传输级）层面设计和实现一个专用的、基于芯片（silicon-based）的CXL控制器，可以实现亚两位数（即低于100纳秒）的往返延迟，这比现有原型报告的250纳秒延迟快3倍以上。这一发现证明了通过优化硬件堆栈，CXL可以成为一种极低延迟的GPU内存扩展方案。</p><p><b>论文贡献</b>: 该论文的主要贡献可以总结为以下三点：</p><ol start="1"><li><b>设计了集成CXL的GPU架构</b>: 设计了GPU的CXL根端口（root port）和内部架构，使GPU设备能够直接访问内存扩展器，无需主机CPU的干预。<a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/685e56d558cb8da5c876b6c6.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/685e56d558cb8da5c876b6c6.png" alt=""></a></li></ol><ol start="2"><li><b>展示了真实的、基于芯片的CXL控制器</b>: 为了实现高速内存扩展，论文展示了一个低延迟CXL控制器的芯片堆栈，并将其集成到GPU硬件的RTL级别。<a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/685e56f858cb8da5c876b83a.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/685e56f858cb8da5c876b83a.png" alt=""></a></li></ol><ol start="3"><li><b>提出了投机性读取和确定性存储机制</b>: 论文设计了两种策略来优化对后端存储介质的访问：投机性读取（Speculative Read）可以预取目标数据页，而确定性存储（Deterministic Store）则通过并发写入来隐藏写操作延迟。</li></ol><h2 id="h2-7">方法策略</h2><p>为了利用其低延迟CXL控制器的发现来扩展GPU内存，研究团队设计了一套完整的硬件和软件策略。</p><p><b>遇到的困难</b>:</p><ol start="1"><li><b>GPU缺乏CXL支持</b>: 当代GPU没有内置的CXL逻辑来直接连接和管理CXL内存设备。</li></ol><ol start="2"><li><b>后端介质延迟</b>: 即使CXL控制器延迟极低，后端连接的存储介质（如DRAM或SSD）本质上仍比GPU本地内存慢。</li></ol><ol start="3"><li><b>写操作的尾延迟</b>: 基于NVM（非易失性存储）的SSD在执行写操作时，可能会因为内部管理活动而出现性能波动或较长的尾延迟。</li></ol><p><b>设计的方法与策略</b>:</p><ol start="1"><li><b>CXL集成GPU架构设计</b>:<p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/685e573a58cb8da5c876bd53.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/685e573a58cb8da5c876bd53.png" alt=""></a> <a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/685e575b58cb8da5c876c01a.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/685e575b58cb8da5c876c01a.png" alt=""></a></p><ul><li>为了解决GPU缺乏CXL支持的问题，论文设计了一个特殊的<b>CXL根复合体 (CXL Root Complex)</b>。</li></ul><ul><li>该复合体包含一个<b>主机桥 (Host Bridge)</b>和<b>多个CXL根端口 (Root Ports)</b>。主机桥内有一个<b>HDM解码器 (HDM Decoder)</b>，负责管理每个根端口所连接的CXL设备的物理地址空间。</li></ul><ul><li>当GPU的计算单元发出内存请求时，该请求被路由到CXL根复合体，HDM解码器根据地址将其映射到正确的根端口，然后CXL控制器将内存请求转换为CXL flit格式并发送给目标CXL设备（DRAM或SSD）。</li></ul></li></ol><ol start="2"><li><b>投机性读取 (Speculative Read, SR)</b>:<p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/685e577858cb8da5c876c24a.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/685e577858cb8da5c876c24a.png" alt=""></a></p><ul><li>为了隐藏后端介质的读取延迟，该策略利用了CXL 2.0的<code>MemSpecRd</code>功能。</li></ul><ul><li>当一个加载（load）请求到达时，控制器会先生成一个SR请求，提前将可能很快被访问的地址发送给CXL端点设备，使其能够预取数据。</li></ul><ul><li>为了避免给端点设备带来过大负担，该机制还会通过CXL的QoS遥测功能监控设备负载（DevLoad），并动态调整SR请求的频率。</li></ul></li></ol><ol start="3"><li><b>确定性存储 (Deterministic Store, DS)</b>:<ul><li>为了解决写操作延迟和性能不稳定的问题（尤其对SSD），DS策略采用了一种“即发即忘”(fire-and-forget)的方法。</li></ul><ul><li>当一个写请求（store）发出时，它会<b>同时写入GPU本地预留内存和后端的CXL SSD</b>。写请求会立即完成，从而向上层计算单元隐藏了后端SSD的实际写入延迟。</li></ul><ul><li>如果检测到SSD写入缓慢或出现尾延迟，后续的写入数据会暂时堆积在GPU内存的预留空间中，形成一个栈，并在后台被清空至SSD，从而保证了写入操作的确定性性能。</li></ul></li></ol><h3 id="h3-8">实验设置与实验结果</h3><ul><li><b>实验平台</b>:<ul><li>实验并非在真实的NUMA系统上模拟。论文团队首先使用<b>尖端硅工艺制造了CXL控制器ASIC</b>。</li></ul><ul><li>然后，他们将这个ASIC和Vortex GPU（一种基于RISC-V的开源GPGPU）的RTL设计集成到一个<b>基于FPGA的定制AIC</b>上，构建了硬件原型。</li></ul><ul><li>最终的性能评估是在一个<b>精确建模该硬件原型的模拟器</b>上进行的。该模拟器使用了从真实硬件（包括ASIC和FPGA原型）运行中提取的参数（如执行时间、流水线统计、总线延迟）进行校准，以确保其行为的准确性。</li></ul></li></ul><ul><li><b>效果与对比</b>:<ul><li><b>对比指标</b>: 主要的性能评估指标是<b>内核执行时间（Normalized Execution Time）</b>和<b>IPC（每周期指令数）</b>。</li></ul><ul><li><b>对比方案</b>:</li></ul><ol start="1"><li><code>UVM</code>: 基准的软件统一内存方案。</li></ol><ol start="2"><li><code>CXL-Proto</code>: 模拟采用业界报道的250ns延迟控制器的CXL方案。</li></ol><ol start="3"><li><code>CXL-Opt</code>: 采用本文提出的亚两位数纳秒延迟控制器的方案。</li></ol><ol start="4"><li><code>CXL-SR</code>: 在<code>CXL-Opt</code>基础上应用投机性读取策略。</li></ol><ol start="5"><li><code>CXL-SSD</code>: 使用CXL连接的Intel Optane SSD作为扩展内存。</li></ol><ol start="6"><li><code>CXL-DS</code>: 在<code>CXL-SSD</code>基础上应用确定性存储策略。</li></ol><ul><li><b>对比公平性与全面性</b>: 对比是公平的，因为所有系统都在同一个模拟器上实现。实验选取了五种具有不同访存特性（读密集型、写密集型）的GPU内核作为工作负载，保证了评估的全面性。</li></ul></li></ul><ul><li><b>实验结果</b>:<p><a data-lightbox="example-1" href="https://pic1.imgdb.cn/item/685e57dc58cb8da5c876c9f8.png"><img loading="lazy" src="https://pic1.imgdb.cn/item/685e57dc58cb8da5c876c9f8.png" alt=""></a></p><ul><li><b>解决问题效果好</b>: <code>CXL-Opt</code>方案显著优于传统的<code>UVM</code>方案，性能提升高达3.5倍，因为它避免了页面错误带来的高昂开销。</li></ul><ul><li><b>比相关工作好</b>: <code>CXL-Opt</code>比模拟业界原型的<code>CXL-Proto</code>性能高出1.34倍，这得益于其优化的低延迟CXL控制器。</li></ul><ul><li><b>消融实验</b>:</li></ul><ul><li><code>CXL-SR</code>相较于<code>CXL-Opt</code>性能提升了1.08倍，证明了投机性读取策略能有效隐藏读延迟。</li></ul><ul><li>对于写密集型工作负载（如Conv和VecAdd），<code>CXL-DS</code>相较于<code>CXL-SSD</code>性能提升了1.65倍，证明了确定性存储策略能有效隐藏写延迟。这些对比清晰地展示了SR和DS各自的贡献。</li></ul></li></ul><h3 id="h3-9">前提假设与局限性</h3><ul><li>论文的核心主张是其自研的CXL控制器实现了亚100纳秒的往返延迟 ，这与业界原型（约250纳秒）相比优势显著，甚至接近原生DDR内存的延迟水平。论文将此归因于“从物理层到事务层的全面优化” ，并推测竞争方案的高延迟源于复用PCIe架构 。然而，文中并未提供任何关于<b>如何实现</b>这些优化的具体技术细节。这使得其关键技术贡献成了一个难以评估的“黑箱”，读者无法判断如此显著的延迟降低是源于何种架构创新，这无疑削弱了该核心主张的可信度与可复现性。</li></ul><ul><li>在探讨GPU内存扩展方案时，本文重点回顾了GPUDirect和UVM等技术 ，但遗漏了当前业界解决大规模模型训练最主流的方案之一：通过高速GPU互联技术（如NVIDIA NVLink/NVSwitch）构建统一内存池。这类技术直接服务于多GPU系统，以极高的带宽和低延迟扩展了单一GPU的可用内存边界。忽略这一性能强大的技术路线，使得文章的比较范围似乎被局限于软件或相对较慢的I/O方案，这可能让读者质疑，论文是否为了凸显其CXL方案的优势而进行了选择性的对比。</li></ul><ul><li>本文以大规模语言模型（LLM）的巨大内存需求作为核心应用挑战 。然而，LLM不仅是内存容量受限（memory-capacity-bound）的应用，更是典型的带宽敏感型（bandwidth-sensitive）工作负载。论文的核心贡献和评估指标却高度集中于优化与衡量延迟（latency）。更重要的是，实验部分选取的 benchmarks（如BFS, SpMV等）与LLM的计算与访存模式差异巨大，并且全文未提供任何关于带宽（bandwidth）的性能数据。这种评估与动机之间的不匹配，使得论文虽然证明了其方案在低延迟方面的优势，但未能直接回应其能否有效满足LLM这类关键应用的带宽需求，从而使其方案的实际应用价值存疑。</li></ul></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../内存池化/Pond" >内存池化</a><ul><li><a href="../../内存池化/Pond" >Pond</a></li></ul><ul><li><a href="../../内存池化/Direct_CXL" >Direct_CXL</a></li></ul><ul><li><a href="../../内存池化/Against_CXL_Memory_Pooling" >Against_CXL_Memory_Pooling</a></li></ul></li></ul><ul><li><a href="../../内存分级/TPP" >内存分级</a><ul><li><a href="../../内存分级/TPP" >TPP</a></li></ul><ul><li><a href="../../内存分级/NeoMem" >NeoMem</a></li></ul></li></ul><ul><li><a href="../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices" >带宽与延迟</a><ul><li><a href="../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices" >Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices</a></li></ul></li></ul><ul><li><a href="../../CXL-SSD/Hello_Bytes" >CXL-SSD</a><ul><li><a href="../../CXL-SSD/Hello_Bytes" >Hello_Bytes</a></li></ul><ul><li><a href="../../CXL-SSD/Cache_in_Hand" >Cache_in_Hand</a></li></ul></li></ul><ul><li><a href="../../simulation/CXL-DMsim" >simulation</a><ul><li><a href="../../simulation/CXL-DMsim" >CXL-DMsim</a></li></ul></li></ul><ul><li><a href="../../CXL探索/Enhanced_Memory_Functions" >CXL探索</a><ul><li><a href="../../CXL探索/Enhanced_Memory_Functions" >Enhanced_Memory_Functions</a></li></ul></li></ul><ul><li><a href="../../内存拓展/Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller" >内存拓展</a><ul><li><a href="../../内存拓展/Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller" >Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../CXL探索/Enhanced_Memory_Functions",".","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>