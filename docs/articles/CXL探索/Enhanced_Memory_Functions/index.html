<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>
        Document
    </title>
    <link rel='stylesheet' href=../../../css/index.css />
    
    <link rel="icon" href="https://raw.githubusercontent.com/learner-lu/picbed/master/logo.png">
</head>

<body class="light">
    <a href="https://github.com/IcarusSong/cxl-papers.git" target="_blank" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <div class="header-navigator"><ul><li><a href="#h1-0">Enhanced_Memory_Functions</a><ul><li><a href="#h2-1">作者以及出版物</a><ul><li><a href="#h3-2">作者</a></li></ul><ul><li><a href="#h3-3">出版物</a></li></ul></li></ul><ul><li><a href="#h2-4">背景</a></li></ul><ul><li><a href="#h2-5">方法</a></li></ul><ul><li><a href="#h2-6">例子</a><ul><li><a href="#h3-7">内存回滚</a></li></ul></li></ul></li></ul></div><div class='markdown-body'><h1 id="h1-0">Enhanced_Memory_Functions</h1><h2 id="h2-1">作者以及出版物</h2><h3 id="h3-2">作者</h3><ul><li>David Boles , Micron Technology, Austin, TX, 78730, USA</li></ul><ul><li>Daniel Waddington , IBM, San Jose, CA, 95120, USA</li></ul><ul><li>David A. Roberts , Micron Technology, Boise, ID, 83707, USA</li></ul><h3 id="h3-3">出版物</h3><p>2023 IEEE Micro</p><h2 id="h2-4">背景</h2><p>CXL是一个开放标准的异步协议，它建立在PCIe物理层之上，允许第三方供应商创造能与CPU共享内存直接交互的设备 。它允许在内存数据平面上进行技术插入，这为将某些功能下推(卸载)到内存子系统创造了可能性。</p><h2 id="h2-5">方法</h2><p>本文提出了EMFs（Enhanced Memory Functionals）的概念。本文的核心是利用CXL协议将传统上由cpu或os执行的功能下推（卸载）到内存控制器中执行。而所谓的EMFs，正是这些被下推的功能。通过在更靠近内存介质的地方执行这些功能，可以实现更高的带宽、更低的延迟和更低的能耗。</p><p>论文中提到，一个有效的EMFs拥有以下一个或多个特性：</p><ul><li>靠近内存介质：能够以低延迟和低能耗访问内存</li></ul><ul><li>数据平面插入能力：可以直接干预内存的read/write</li></ul><ul><li>独立于cpu的cache层次：能够观察到主内存的真实状态，不受到缓存的影响</li></ul><ul><li>独立于ISA：避免受到微架构复杂性（例如内存屏障、推测执行）的影响</li></ul><ul><li>与虚拟内存子系统分离：能够提高实现效率，并将监控粒度与操作系统的页面大小解耦</li></ul><ul><li>与主机处理器交互能力：能够与主机协调以维护数据一致性</li></ul><p>论文中列举了一个表格，提供了六类设想的EMFs</p><table><tr><th><b>类别</b></th><th><b>增值功能</b></th></tr><tr><td style="text-align:left">                <b>I. 事务处理</b></td><td style="text-align:left">                a) 在非易失性内存（NVM）上实现透明的崩溃一致性事务（如回滚）。<br>b) 在易失性内存上实现事务，用于分布式系统中的共享内存一致性。</td></tr><tr><td style="text-align:left">                <b>II. 日志与追踪</b></td><td style="text-align:left">                a) 软件调试、性能分析和执行回放。<br>b) 内存快照（如虚拟机实时迁移）。</td></tr><tr><td style="text-align:left">                <b>III. 数据移动</b></td><td style="text-align:left">                a) 访问分析（如内存访问热力图）。<br>b) 性能计数器（如访问计数、访问延迟、平均带宽）。<br>c) 缓存与内存分层：按需将数据行移动到更快或更慢的内存（如本地与远程内存之间）。<br>d) 网络/结构桥接（如CXL到RDMA）。<br>e) 预取：利用访问模式提前获取缓存行。<br>f) 地址转换——为重新映射和共享添加额外的内存转换层。</td></tr><tr><td style="text-align:left">                <b>IV. 安全</b></td><td style="text-align:left">                a) 静态内存加密/解密。<br>b) 安全飞地；限制对内存区域的访问（时间或空间上）。<br>c) 持续数据保护；使用写时复制日志记录创建内存写入历史。<br>d) 内存取证；“嗅探”内存事务以进行网络安全和审计（如识别未授权数据访问）。<br>e) 恶意软件检测（如行锤攻击）与防护。</td></tr><tr><td style="text-align:left">                <b>V. 可靠性、可用性、可维护性（RAS）</b></td><td style="text-align:left">                a) 内存复制以实现容错（如跨DIMM、跨节点）。<br>b) 跨本地或远程内存的纠删编码。<br>c) 零拷贝重新挂接以实现高可用性。<br>d) 详细的硬件故障可见性。<br>e) 为低可靠性、低成本内存提供额外的ECC编码。</td></tr><tr><td style="text-align:left">                <b>VI. 数据效率</b></td><td style="text-align:left">                a) 压缩；异步压缩并将内存区域分页到其他内存或存储区域。<br>b) 去重；共享内容相同的内存区域（如跨虚拟机的内核代码页）。<br>c) 内存填充；向内存写入零或特定字节模式（如单位矩阵）。<br>d) 领域特定操作（如矩阵乘法）。</td></tr></table><h2 id="h2-6">例子</h2><p>本文针对提出的EMFs提出了两个例子，一个是内存访问热图（Access Heat Maps），即将内存访问分析卸载到CXL控制器上，这在<b>NeoMem</b>中已经实现；另一个是内存回滚 (Memory Roll-back)来实现崩溃一致性</p><h3 id="h3-7">内存回滚</h3><p><b>问题</b>：在持久性内存（Persistent Memory）编程中，实现崩溃后数据一致性是一个关键挑战。传统的纯软件方法（如英特尔的PMDK）需要修改应用程序代码，使用特定的数据结构，并且会带来巨大的性能开销和写放大问题。</p><p><b>EMF解决方案</b>：论文提出了一种内存回滚功能，通过硬件来保证事务的原子性 。该功能利用“微堆”（microheaps）来管理与特定数据结构关联的内存 。在事务开始时，控制器会自动保存相关内存区域的快照。事务期间的写操作，硬件会自动记录修改前的旧数据（undo log） 。事务结束后，可以提交修改或中止事务并恢复到初始状态。</p><p><b>验证</b>：研究人员在一个基于FPGA的CXL内存设备上实现了此功能。与使用PMDK的软件方案相比，内存回滚EMF在执行红黑树操作时，写入内存介质的缓存行数量显著减少，写放大因子从3.5倍-4.1倍降低。这证明了该方法不仅效率更高，而且能够让现有软件库更容易地支持持久性内存。</p><p>对于崩溃一致性，已有CXL方面的学术研究，暂时留坑，之后补上。</p></div>
    <div class="dir-tree"><ul><li><a href="../../md-docs/README" >README</a></li></ul><ul><li><a href="../../内存池化/Pond" >内存池化</a><ul><li><a href="../../内存池化/Pond" >Pond</a></li></ul><ul><li><a href="../../内存池化/Direct_CXL" >Direct_CXL</a></li></ul><ul><li><a href="../../内存池化/Against_CXL_Memory_Pooling" >Against_CXL_Memory_Pooling</a></li></ul></li></ul><ul><li><a href="../../内存分级/TPP" >内存分级</a><ul><li><a href="../../内存分级/TPP" >TPP</a></li></ul><ul><li><a href="../../内存分级/NeoMem" >NeoMem</a></li></ul></li></ul><ul><li><a href="../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices" >带宽与延迟</a><ul><li><a href="../../带宽与延迟/Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices" >Demystifying_CXL_Memory_with_Genuine_CXL-Ready_Systems_and_Devices</a></li></ul></li></ul><ul><li><a href="../../CXL-SSD/Hello_Bytes" >CXL-SSD</a><ul><li><a href="../../CXL-SSD/Hello_Bytes" >Hello_Bytes</a></li></ul><ul><li><a href="../../CXL-SSD/Cache_in_Hand" >Cache_in_Hand</a></li></ul></li></ul><ul><li><a href="../../simulation/CXL-DMsim" >simulation</a><ul><li><a href="../../simulation/CXL-DMsim" >CXL-DMsim</a></li></ul></li></ul><ul><li><a href="../../CXL探索/Enhanced_Memory_Functions" >CXL探索</a><ul><li><a href="../../CXL探索/Enhanced_Memory_Functions" >Enhanced_Memory_Functions</a></li></ul></li></ul><ul><li><a href="../../内存拓展/Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller" >内存拓展</a><ul><li><a href="../../内存拓展/Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller" >Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller</a></li></ul></li></ul></div>
    <div class="zood"><a class="" href="https://github.com/luzhixing12345/zood" target="_blank">zood</a></div>
    <script type="text/javascript" src="../../../js/next_front.js"></script><script>addLink("../../simulation/CXL-DMsim","../../内存拓展/Breaking_Barriers:Expanding_GPU_Memory_with_Sub-Two_Digit_Nanosecond_Latency_CXL_Controller","ab");</script><script type="text/javascript" src="../../../js/change_mode.js"></script><script>addChangeModeButton("../../../img/sun.png","../../../img/moon.png");</script><script type="text/javascript" src="../../../js/copy_code.js"></script><script>addCodeCopy("../../../img/clipboard.svg","../../../img/clipboard-check.svg");</script><script type="text/javascript" src="../../../js/navigator.js"></script><script type="text/javascript" src="../../../js/picture_preview.js"></script><script type="text/javascript" src="../../../js/global_js_configuration.js"></script>
</body>

</html>